<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android自动构建]]></title>
      <url>%2F2017%2F01%2F09%2FProgramming-Summary%2FAndroid%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[[TOC] 1. 搭建环境1.1 开发环境安装以下组件并配置环境变量 CentOS release 6.5 (Final) 64bit git 2.10.0 Gradle 2.4 JDK 1.8 Android SDK Platform 23 Android Build Tools 23.0.02 Android Extras（Android support Library） TIPS： centos 64 bit 上buil-tools 中的aapt工具不能很好运行，需要安装 yum install libgcc.i686 yum install zlib.i686 yum install glibc.i686 … 组件也可以通过插件自动安装，为了便于以后管理，这里选择自己安装 1.2 第三方平台 coding.net 代码托管 蒲公英应用托管平台 2. 安装和配置Jenkins插件2.1 安装插件 jenkins 1.6 gradle plugin 1.25 2.2 插件配置进入系统管理-&gt;系统设置，并添加以下配置 3. Jenkins Job 配置3.1 源代码拉取 3.2 构建触发器30分钟一次 3.3 执行构建3.3.1 执行构建 3.3.2 构建后上传至蒲公英，并保存返回二维码 12345678910111213function jsonval &#123; temp=`echo $json | sed &apos;s/\\\\\//\//g&apos; | sed &apos;s/[&#123;&#125;]//g&apos; | awk -v k=&quot;text&quot; &apos;&#123;n=split($0,a,&quot;,&quot;); for (i=1; i&lt;=n; i++) print a[i]&#125;&apos; | sed &apos;s/\&quot;\:\&quot;/\|/g&apos; | sed &apos;s/[\,]/ /g&apos; | sed &apos;s/\&quot;//g&apos; | grep -w $responsekey` echo $&#123;temp##*|&#125;&#125;json=`curl -F &quot;file=@YOUR_APK_PATH&quot; -F &quot;uKey=YOUR_USER_KEY&quot; -F &quot;_api_key=YOUR_API_KEY&quot; http://www.pgyer.com/apiv1/app/upload`responsekey=&apos;appQRCodeURL&apos;responsevalue=`jsonval`rm -rf pgyermkdir pgyercd pgyercurrentDate=`date +%Y_%m_%d_%H_%M_%S`wget -O $currentDate.jpg $responsevalue 3.4 构建后存档 4. Android 项目配置创建local.properties放于根目录，并将sdk.dir配置为本地Android sdk目录 5. 构建取包查看图片扫码进入蒲公英下载页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[背包问题]]></title>
      <url>%2F2017%2F01%2F08%2FProgramming-Summary%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[0-1背包问题 每件物品或被带走，或被留下，（需要做出0-1选择）。 使用动态规划 动态规划算法： 部分背包问题 可以只带走某个物品的一部分，不必做出0-1选择。 不具有后效性，可使用贪心算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AIDL]]></title>
      <url>%2F2017%2F01%2F07%2FProgramming-Summary%2FAIDL%2F</url>
      <content type="text"><![CDATA[全称 Android Interface Definition Language，是一种Android内部进程间通信的机制 只有你允许客户端从不同的应用程序为了进程间的通信而去访问你的service，以及想在你的service处理多线程时才建议使用AIDL。 Demo地址 1. 项目说明项目包含两个部分: app 客服端，请求aidl服务 remote-app 服务端，提供客服端调用的接口服务 2. 基本流程 在服务端声明一个aidl接口，build后产生java文件，里面包含有IBinder的子类和proxy类,同时创建service类用于响应客户端的AIDL请求 客服端将服务端的AIDL接口拷贝过去，然后build也会产生一个java文件，在代码中通过ServiceConnection类连接远程服务并在其方法中获得AIDL接口对象就可以调用自己定义的方法了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Binder]]></title>
      <url>%2F2017%2F01%2F05%2FProgramming-Summary%2FAndroid%20Binder%2F</url>
      <content type="text"><![CDATA[用途原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android.graphics 包]]></title>
      <url>%2F2017%2F01%2F03%2FProgramming-Summary%2Fandroid.graphics%20%E5%8C%85%2F</url>
      <content type="text"><![CDATA[matrixhttps://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B09%5DMatrix_Basic.md?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[问题以及解决]]></title>
      <url>%2F2017%2F01%2F01%2FProgramming-Summary%2F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[NO.1 问题描述：home键或者其他方式程序进入后台后，一段时间回到前台界面显示信息出错 原因分析：由于app进入后台时间太久没有唤起，被系统回收 问题解决：在application类的onCreate方法里面对重新启动进行监听并重新启动进入后台时候的Activity NO.2 问题描述：postDelay+Dialog引起的窗体泄露 原因分析：Android中消息队列postDelay+Dialog引起的窗体泄露的主要原因是，当床窗体压入栈或者finish掉后，Activity由于需要处理postDelay而不能及时销毁，因此造成了一个问题，当dialog触发show方法时，由于window和activity已经分开了，因此便会造成窗体泄露。 问题解决：通过对Activity的状态进行监听确定是否显示dialog，见代码1234567891011121314151617181920212223242526272829private boolean isActive = true;public void onResume()&#123; super.onResume(); isActive = true;&#125;public void onPause()&#123;&lt;!--more--&gt; super.onPause(); isActive = false;&#125; public boolean activityIsActivity()&#123; return isActive;&#125; public void showAlertDialog()&#123; if(activityIsActive()) //只有窗体处于活动状态时执行此程序 &#123; AlertDialog.Builder builder = new AlertDialog.Builder(activity); builder.setTitle("hello world") .setCancelable(false) .setMessage("Hello"); builder.create().show(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android分辨率兼容]]></title>
      <url>%2F2016%2F12%2F30%2FProgramming-Summary%2FAndroid%E5%88%86%E8%BE%A8%E7%8E%87%E5%85%BC%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[1. 相关概念 PX:像素点,图片的尺寸 PT:1/72 inch，物理单位1inch＝2.54cm DPI(Dots per inch):每个英寸(物理单位)的px数。 DP(DIP,Density-independent Pixels):DP是人为规定的一个单位。官方文档中解释one DIP is one pixel on an approximately 160 dpi screen (for example a 240x320, 1.5”x2” screen),所以在320dpi的设备上，1DIP = 2PX,以此类推。 SP(Scale-independent Pixels) 总结: android.util.DisplayMetricsd源码中的density是DP和PX转换的因子，公式为$$PX = density * DP$$,而$$density = 当前设备的DPI/160$$ 所以说，在160DPI(即每个英寸有160个像素点)的设备上，density 是1，代表每个DP包含1个像素，在320DPI设备上density是2，代表每个DP包含2个像素。 最终的公式是：$$PX = {DPI * DP \over 160} $$ 因为DPI是由设备决定的，而现在主流的设备也是相差不多，比如1080P的DPI一般就是5inch,那么DPI就是440，density为2.75，那么屏幕的宽度1080px ＝ 1080/2.75 ＝ 392dp。 二.适配方案 首先，保证长度单位均使用DP作为单位（特殊情况，如根据屏幕分辨率动态设置除外）,同时使用灵活的自适应布局风格，还可以利用LineaLayout的weight对布局进行比例分割。 根据不同分辨率，取不同的drawable和dimen，而layout则使用一套。比如设计师给到一张在1080P手机上100x100的切图，那么在480x800手机上就应该进行缩小，理论上是一半，实际上还需要根据真机做调整。 文件夹 DPI ldpi 0-120 mdpi 120-160 hdpi 160-240 xhdpi 240-320 xxhdpi 320-480 123456res/drawable (default)res/drawable-ldpi/ (240x320 and nearer resolution)res/drawable-mdpi/ (320x480 and nearer resolution)res/drawable-hdpi/ (480x800, 540x960 and nearer resolution)res/drawable-xhdpi/ (720x1280 - Samsung S3, Micromax Canvas HD etc)res/drawable-xxhdpi/ (1080x1920 - Samsung S4, HTC one, Nexus 5, etc) 123456res/values/dimens.xml(default)res/values-ldpi/dimens.xml (240x320 and nearer resolution)res/values-mdpi/dimens.xml (320x480 and nearer resolution)res/values-hdpi/dimens.xml (480x800, 540x960 and nearer resolution)res/values-xhdpi/dimens.xml (720x1280 - Samsung S3, Micromax Canvas HD, etc) res/values-xxhdpi/dimens.xml (1080x1920 - Samsung S4, HTC one, etc)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Support Library]]></title>
      <url>%2F2016%2F12%2F28%2FProgramming-Summary%2FAndroid%20Support%20Library%2F</url>
      <content type="text"><![CDATA[详见官方文档 1. 主要分类 包名 用途 API级别 v4 Support Library 最基础的library，包含多方面的代码 4(1.6) v7 Support Library 有多个子包，比如MD的一些UI组件，调色板工具等 7(2.1) v8 Support Library RenderScript 高性能计算 8 v13 Support Library 更多的Fragment支持 13(3.2) v14 Support Library 配置列表支持 14 v17 Support Library for TV 17 Multidex Support Library 解决65536方法数限制 - Annotations Support Library 注解库 - Design Support Library MD组件支持 - Custom tabs Support Library 自定义Tab页面 - Percent Support Library 百分比UI - App Recommendation Support Library for TV -]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用Android优化工具]]></title>
      <url>%2F2016%2F12%2F26%2FProgramming-Summary%2F%E5%B8%B8%E7%94%A8Android%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[TraceView参考http://www.trinea.cn/android/android-traceview/代码的性能优化，CPU占用等信息 Lint代码优化 hierarchyviewer显示布局层级以及每个view花费在各阶段的时间（onMeasure OnLayout onDraw）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存优化]]></title>
      <url>%2F2016%2F12%2F24%2FProgramming-Summary%2F%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[参考博文 http://blog.csdn.net/innost/article/details/9008691 http://www.trinea.cn/android/performance/ http://hukai.me/android-performance-patterns/ 主要工具 Eclipse插件 MAT memory analyser tool LeakCanary 常见内存问题 MAT使用教程 http://inter12.iteye.com/blog/1407492http://www.importnew.com/2433.html 其他 Shallow heap &amp; Retained heap 区别list objects – with outgoing references : 查看这个对象持有的外部对象引用。list objects – with incoming references : 查看这个对象被哪些外部对象引用。static对象不会被gc回收]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[批量打包工具]]></title>
      <url>%2F2016%2F12%2F22%2FProgramming-Summary%2F%E6%89%B9%E9%87%8F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[先上工具地址 原理该打包工具参考了美团的打包方案。由于apk压缩文件的META-INF目录下文件不影响签名结果，所以可以在打包签名后在META-INF目录下生成相应的渠道标记，在程序运行时通过程序代码读取打包渠道号即可设置渠道。 使用方法 在marketlist.txt文件中配置渠道列表 运行build.py（需安装python运行环境） Python脚本代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import osimport shutilimport zipfile# 空文件 便于写入此空文件到apk包中作为channel文件src_empty_file = 'temp.txt'# 创建一个空文件（不存在则创建）f = open(src_empty_file, 'w') f.close()&lt;!--more--&gt;# 获取渠道列表channel_file = 'marketlist.txt'f = open(channel_file)lines = f.readlines()f.close()# 获取当前目录中所有的apk源包src_apks = []for file in os.listdir(): if os.path.isfile(file): extension = os.path.splitext(file)[1][1:] if extension in 'apk': src_apks.append(file) # file name (with extension)src_apk = src_apks[0]src_apk_file_name = os.path.basename(src_apk)# 分割文件名与后缀temp_list = os.path.splitext(src_apk_file_name)# name without extensionsrc_apk_name = temp_list[0]# 后缀名，包含. 例如: ".apk "src_apk_extension = temp_list[1]# 创建生成目录,与文件名相关output_dir = src_apk_name +"各渠道包"+ '/'# 目录不存在则创建if not os.path.exists(output_dir): os.mkdir(output_dir)# 遍历渠道号并创建对应渠道号的apk文件linesIndex = 1for line in lines: # 获取当前渠道号，因为从渠道文件中获得带有\n,所有strip一下 target_channel = line.strip() if "#" in line[0:1] : print("渠道"+target_channel[1:]+"跳过") continue # 拼接对应渠道号的apk target_apk = output_dir + src_apk_name + "_" + target_channel + src_apk_extension # 拷贝建立新apk shutil.copy(src_apk, target_apk) # zip获取新建立的apk文件 zipped = zipfile.ZipFile(target_apk, 'a', zipfile.ZIP_DEFLATED) # 初始化渠道信息 empty_channel_file = "META-INF/kdlcchannel_"+target_channel # 写入渠道信息 zipped.write(src_empty_file, empty_channel_file) # 关闭zip流 zipped.close() print(linesIndex,".渠道 "+target_channel+" 打包完成") linesIndex = linesIndex + 1 Android获取渠道号的代码12345678910111213141516171819202122232425262728293031323334public static String getAppChannel(Context context)&#123; ApplicationInfo appinfo = context.getApplicationInfo(); String sourceDir = appinfo.sourceDir; String ret = ""; ZipFile zipfile = null; try &#123; zipfile = new ZipFile(sourceDir); Enumeration&lt;?&gt; entries = zipfile.entries(); while (entries.hasMoreElements()) &#123; ZipEntry entry = ((ZipEntry) entries.nextElement()); String entryName = entry.getName(); if (entryName.startsWith("META-INF/kdlcchannel")) &#123; ret = entryName; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (zipfile != null) &#123; try &#123; zipfile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; String[] split = ret.split("_"); if (split != null &amp;&amp; split.length &gt;= 2) &#123; return ret.substring(split[0].length() + 1); &#125; else &#123; return "MarketNotSet"; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义UI-书架]]></title>
      <url>%2F2016%2F12%2F20%2FProgramming-Summary%2F%E8%87%AA%E5%AE%9A%E4%B9%89UI-%E4%B9%A6%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[1. 效果图 2. 技术细节 事件冲突解决 坐标传递修正 拖动书记卡顿问题解决 拖动避让逻辑设计实现 … 3. 阅读王下载链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery入门教程]]></title>
      <url>%2F2016%2F12%2F19%2FProgramming-Summary%2FjQuery%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[官方API jQuery()/$()的几种用法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信小程序]]></title>
      <url>%2F2016%2F12%2F18%2FProgramming-Summary%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[[TOC] 1. 学习资料 官方文档 Github整理 2. 框架app.json:配置工程 3. demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义UI-电影在线选座]]></title>
      <url>%2F2016%2F12%2F18%2FProgramming-Summary%2F%E8%87%AA%E5%AE%9A%E4%B9%89UI-%E7%94%B5%E5%BD%B1%E5%9C%A8%E7%BA%BF%E9%80%89%E5%BA%A7%2F</url>
      <content type="text"><![CDATA[1. 效果图 2. 技术细节 触摸事件处理 绘制坐标更新 放大缩小中心坐标计算 … 3. 掌上生活下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开启前端之路]]></title>
      <url>%2F2016%2F12%2F17%2FProgramming-Summary%2F%E5%BC%80%E5%90%AF%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[html css javascript 1. HTML1.1 标签 input select form div 2. CSS为控件添加样式 2.1 为控件添加样式的方式2.1.1 指定style1&lt;div style="border:1px solid #F4BF20;padding:5px 0px 5px 0px ;margin-bottom:12px;"&gt;&lt;/div&gt; 2.1.2 指定id+样式表2.1.3 指定class+样式表3. JavaScript bootstrap jquery $ lodash _ mustache parsleyjs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[密码学简介]]></title>
      <url>%2F2016%2F12%2F16%2FProgramming-Summary%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[相关概念 加密方式分类 对称加密：只有一个秘钥，既可以用于加密，也可以用于解密，所以密钥不能对外泄露。如DES 非对称加密(公开密钥加密)：有两个密钥，一个叫公钥，一个叫做私钥，任何一个都可以用于加密同时也可以用于解密，用公钥加密的只能用私钥解密，反之亦然。私钥不能泄漏，公钥提供给需要通信的客户端。如RSA 签名：一般是在加密前，对传递信息内容进行hash后生成hash值（指纹），将hash值（指纹）加密得到签名，然后将签名放入传递信息中一起发送出去。接受方受到以后对签名进行解密，并对信息正文计算hash值（指纹），并比较hash值是否相同判断信息是否被篡改过。实质利用的hash算法的不可逆。 数字证书 数字证书实质是为了解决公钥派发的问题。因为任何人都可以生成公钥和私钥。只有系统中受信任的证书组织的证书才是可用的。 参考： http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2016%2F12%2F14%2FProgramming-Summary%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[主要介绍常用的一些git命令 基础命令 12git add 命令（多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等） git status 命令，用来查看发生变动的文件。 查看提交1234git log 查看commit的历史git show &lt;commit-hash-id&gt; 查看某次commit的修改内容git log -p &lt;filename&gt; 查看某个文件的修改历史git log -p -2 查看最近2次的更新内容 分支管理1234567git branch --track experimental origin/experimental 拉取并追踪分支 git branch -d &lt;branch_name&gt; 删除本地分支 git push origin --delete branch_3.0_liaoheng 删除远程分支&lt;!--more--&gt;git branch -vv 查看本地分支和远程分支的跟踪关联关系 git checkout -b myfeature 以当前分支为基础创建新分支git branch --set-upstream-to=origin/branch_3.0_liaoheng branch_3.0_liaoheng 将本地分支与远程分支关联 切换git源：1234git remote remove origingit remote add origin https://xxxx.git 将本地库添加到远程git push -u origin --all # pushes up the repo and its refs for the first time 上传所有文件git push -u origin --tags # pushes up any tags 标签管理123456git tag -a v1.1.4 -m &quot;tagging version 1.1.4&quot; #打标签git tag #列出标签git push --tags 推送所有本地标签到远程仓库git push 仓库名 标签名 eg. git push origin v1.0 推送本地标签到远程仓库git push origin --delete tag &lt;tagname&gt; 删除远程taggit tag -d v1.1.4 删除本地仓库标签 回滚（reset &amp;&amp; revert） git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 参考：http://samael65535.github.io/git/2013/01/18/git/ http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html 12HEAD 最近一个提交HEAD^ = HEAD^1 上一次 reset: 直接回退，将repository的版本进行回退，工作区的状态会根据参数不同有不同的结果 1git reset HEAD^1 将分支的HEAD指针指向倒数第二个提交（默认mixed策略，即保留工作区代码，不保留仓库和暂存区内容，如果要重新提交，需要执行git add .） revert：以新提交覆盖旧的提交达到回退的目的，如果修改已经不是最新的commit，则只能使用git revert。 12git revert HEAD 撤销最近的一次提交git revert HEAD^1 撤销倒数第二条提交（倒数第一条不撤销），通过产生一个commit覆盖倒数第二条commit，但是不会覆盖最新的一条（倒数第一条） 其他git ls-files –stage 显示index文件（.git目录下） 内容，即暂存区信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于git版本控制协议一些理解]]></title>
      <url>%2F2016%2F12%2F12%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8Egit%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[引用（即指针）对于理解git非常重要，git的分支、tag只是指向了不同commit的指针，不是实际文件. 常用git命令 git版本控制协议结构图 关于暂存区的理解 1.图中index就是stage状态(暂存区)，index保存的是当前所有文件最新的git对象对应的hash值，使用commit命令后会将这些最新的状态提交到head中，head保存的就是该分支所有文件最新的状态，属于git仓库信息 2.Git index 可以看作是工作目录和Git库目录之间的暂存区，暂存区（stage或者叫index） 存储的是整个文件，如果文件修改add到暂存区，那么就会覆盖文件的上个版本，所以一定不会发生冲突 3.切换分支前要把修改的未提交的内容提交，不然切换分支后修改内容在另一个分支上任然可见，这样提交的时候就会有不需要的内容被提交（stash可以解决这个问题）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络地址分类]]></title>
      <url>%2F2016%2F12%2F10%2FProgramming-Summary%2F%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[A类地址：4个8位位组（octets）中第一个octet代表网络号，剩下的3个代表主机位。范围是0xxxxxxx，即0到127。 B类地址：前2个octets代表网络号，剩下的2个代表主机位。范围是10xxxxxx，即128到191。 C类地址：前3个octets代表网络号，剩下的1个代表主机位。范围是110xxxxx，即192到223。 D类地址：多播地址，范围是224到239。 E类地址：保留地址，实验用，范围是240到255。 ###一些特殊的IP地址： IP地址127.0.0.1：本地回环（loopback）测试地址 广播地址：255.255.255.255 IP地址0.0.0.0：代表任何网络 网络号全为0：代表本网络或本网段 网络号全为1：代表所有的网络 主机位全为0：代表某个网段的任何主机地址 主机位全为1：代表该网段的所有主机 专用IP地址： 就是我们在3类地址中常见到内网的IP段。10.0.0.0–10.255.255.255172.16.0.0–172.31.255.255192.168.0.0–192.168.255.255]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode题解]]></title>
      <url>%2F2016%2F12%2F09%2FProgramming-Summary%2FLeetCode%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[[TOC] 1. 题目名称解题思路代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Quick Response Code]]></title>
      <url>%2F2016%2F12%2F08%2FProgramming-Summary%2FQuick%20Response%20Code%2F</url>
      <content type="text"><![CDATA[日本DENSO WAVE公司发明，应用最广泛的二维码之一，可以快速获取信息的内容，采用深色表示1，浅色表示0 参考文档：http://www.qrcode.com/en/about/standards.html &amp; ISO标准 1. 特点 扫描时不用完全对准二维码即可完成识别 支持多种内容类型，字符串，图片，视频等 纠错能力强纠错等级设置： 2. 版本(40种规格) 21x21(四角计算在内) 25x25 29x29 … 177x177生成二维码会根据原始信息的容量选择最优的版本 3. 原理TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[regular expression]]></title>
      <url>%2F2016%2F12%2F06%2FProgramming-Summary%2Fregular%20expression%2F</url>
      <content type="text"><![CDATA[简写为regex、regexp或RE，即字符匹配 ###元字符(可以匹配某一类字符) 表示 含义 \d 匹配一个数字 . 元字符，匹配任何除换行符意外的字符 \w 匹配字母或数字或下划线或汉字 ###数量 *表示任意数量{n,m}至少n个，至多m个]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编程语言分类]]></title>
      <url>%2F2016%2F12%2F04%2FProgramming-Summary%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[=== 众所周知，编程语言有很多种，以下是对编程语言的几种常见分类标准 按照应用执行过程进行分类，对于高级语言需要转化成机器语言才能够执行 机器语言 汇编语言 高级语言 按照执行前准备进行分类 编译型语言 在执行前需要经过编译成机器语言，如C、C++ 解释型语言 在运行时才转化为机器语言，所以效率相对于编译型语言比较低，如Java、C#，脚本语言可以理解为解释型语言，在运行时通过解释器执行 按照语言结构特性 函数式编程语言 函数是第一公民 面向过程变成语言 面向对象编程语言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Annotation]]></title>
      <url>%2F2016%2F12%2F02%2FProgramming-Summary%2FAnnotation%2F</url>
      <content type="text"><![CDATA[参考 http://www.infoq.com/cn/articles/cf-java-annotation http://www.trinea.cn/android/java-annotation-android-open-source-analysis/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类加载器]]></title>
      <url>%2F2016%2F11%2F30%2FProgramming-Summary%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
      <content type="text"><![CDATA[1. Java的Classloader BootStrapClassloader：加载 jre/lib 目录下的核心 API ExtClassloader：加载jre/lib/ext 目录下jar包 AppClassloader：加载CLASSPATH中的类，我们编写的应用类默认情况下都是通过 AppClassLoader 进行加载的。 Custom Classloader：可以自定义加载路径 每个类加载器都缓存有自己的一份已加载类名字空间。加载类并不会创建类的实例。 整个加载过程如下图： 2. Android的ClassloaderAndroid中的ClassLoader体系 PathClassLoader:加载系统类和已安装的应用类的加载器DexClassLoader:可以用来从.jar和.apk加载类，可以用来执行非安装的程序代码。 相关代码在android源码中的路径：./libcore/dalvik/src/main/java/dalvik 参考 https://www.ibm.com/developerworks/cn/java/j-lo-hotswapcls/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发]]></title>
      <url>%2F2016%2F11%2F28%2FProgramming-Summary%2F%E5%B9%B6%E5%8F%91%2F</url>
      <content type="text"><![CDATA[java.util.concurrent 1. 锁1.1 锁的种类 自旋锁：是将当前线程执行循环CAS 可重入锁（可中断锁）：ReentrantLock 和synchronized 都是 可重入锁（http://www.iteedu.com/plang/java/superjava/threadsafe/lockInterruptibly.php） 1.2 Java中锁的实现 循环CAS(compareAndSet缩写)实现自旋锁 12345678910111213141516 public class SpinLock &#123; private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;(); public void lock()&#123; Thread current = Thread.currentThread();&lt;!--more--&gt; while(!sign .compareAndSet(null, current))&#123; &#125; &#125; public void unlock ()&#123; Thread current = Thread.currentThread(); sign .compareAndSet(current, null); &#125;&#125; 使用synchronized和wait notify实现锁 12345678910111213public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; //不用if，而用while，是为了防止假唤醒 wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false; notify(); &#125;&#125; 使用方法 12345678910public class Counter&#123; private Lock lock = new Lock(); private int count = 0; public int inc()&#123; lock.lock(); this.count++; lock.unlock(); return count; &#125;&#125; 2. synchronized3.wait,notify,sleep wait和notify都是释放锁，sleep不释放 synchronized()的代码块中运行完就释放锁了 wait和notify必须先获得唯一控制权，一般用加锁实现 4. 线程池4.1 线程池分类按照线程池是否固定大小，可以将线程池分为一下两类： 固定大小的线程池 newFixedThreadPool newScheduledThreadPool（newFixedThreadPool的扩展，可以指定线程数，同时可以指定任务执行的起始时间和时间间隔） newSingleThreadExecutor（也是newFixedThreadPool的特例，固定大小为1） 不固定大小的线程池 newCachedThreadPool 4.2 创建线程池通过Executors类创建ExecutorService. 12ExecutorService realExecutor = Executors.newSingleThreadExecutor();realExecutor.execute(runnable); ExecutorService相关类和接口关系： 5. 阻塞队列借助Lock实现 参考 深入JVM锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态代理]]></title>
      <url>%2F2016%2F11%2F26%2FProgramming-Summary%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[1. 代理的概念： 图中A是调用者，B是代理类，C是委托类，也称作被代理类。 代理类和被代理类一般实现相同的接口。 2. 动态代理 InvocationHandler相对于OperateImpl是代理类，相对于Proxy是委托，是一个双重角色。 MyProxy类是调用public static Object java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler)生成的一个中间类，MyProxy类继承自java.lang.reflect.Proxy,并实现参数interfaces的所有接口,在接口的实现中调用InvocationHandler，这是第一次代理，在InvocationHandler的invoke方法中调用OperateImpl的方法，这是第二次代理。 参考： 1.http://www.infoq.com/cn/articles/cf-java-reflection-dynamic-proxy2.http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Generic]]></title>
      <url>%2F2016%2F11%2F24%2FProgramming-Summary%2FGeneric%2F</url>
      <content type="text"><![CDATA[类型擦除：Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。 关于T,K,V…以及通配符?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO]]></title>
      <url>%2F2016%2F11%2F22%2FProgramming-Summary%2FIO%2F</url>
      <content type="text"><![CDATA[1. IO首先看一下类继承关系 命名规则其实就是 操作对象 + 读写方式 字节流不需要处理编码，字节流和字符流转换才需要处理编码 1.1 IO的要素 内存（缓冲区） 流（通道） 操作对象 1.2 操作对象 byte[]对象 String对象 File对象 套接字 1.3 方向 Input/Reader:从对象到内存 Output/Writer:从内存到对象 1.4 读写方式 字节(InputStream/OutputStream)：一次读取一个字节 字符(Reader/Writer)：其实字符流可以看做是一种包装流，它的底层还是采用字节流来读取字节 1.5 特性 Streams one byte at a time. Good for binary data.byte oriented stream (8 bit)good for binary data such as a Java .class filegood for “machine-oriented” data Readers/Writers one character at a time. Good for text data.char (utf-16) oriented stream (16 bit)good for text such as a Java sourcegood for “human-oriented” data Buffered many bytes/characters at a time. Good almost all the time. 1.6 编码问题http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/ http://cenalulu.github.io/linux/character-encoding/ java运行时的默认编码可以通过Charset.defaultCharset()获取，其实质是获取当前系统的编码格式，如果系统没有设置，就是UTF-8，一般都会有设置。 编码发生在字节和字符的转化过程中,见下图 HTTP协议中，在Header里指定字符集，在客户端根据指定字符集将body里的内容（字节数组）解码成相应字符（如字符串） 对于String本身和字符集并无关系，字符集只在编码和解码的过程中发挥作用，他会对编码和解码的结果产生影响。 12字节-&gt;字符: 解码（指定字符集）字符-&gt;字节: 编码（指定字符集） 2. NIO 传统流I/O是基于字节的，所有I/O都被视为单个字节的移动；而NIO是基于块的，大家可能猜到了，NIO的性能肯定优于流I/O 2.1 相关概念 缓冲区 通道 内存映射文件：一次数据拷贝和两次数据拷贝的区别 异步IO 参考：http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lambda]]></title>
      <url>%2F2016%2F11%2F20%2FProgramming-Summary%2FLambda%2F</url>
      <content type="text"><![CDATA[Outline Lambda定义和结构 java.util.function（java8功能性接口） java.util.stream（java8流式接口） 一、Lambda定义和结构 Lambda表达式的定义：Java8引入Lambda表达式的目的是简化内部类的使用，其实质仍然是一个函数或者接口的实现。 虽然称作Lambda表达式，但是不同于一般的可计算的表达式，Lambda表达式是一个接口（函数）的实现，也可以理解成匿名类的缩写。 注：对于一个接口如果有多个未实现的方法，则不能使用Lambda表达式，可以有default和static方法方法 基本结构：( 形式参数 ) -&gt; { 方法实现 } 形式参数的参数类型可以省去，编译器可以自动判断e.g.1Collections.sort(list, (x, y) -&gt; y - x) 上面代码中的Lambda表达式：(x, y) -&gt; y - x 实现的就是 java.util.Comparator 接口的compare(T o1, T o2);```方法，虽然代码中没有显式指明，但是编译器会自动根据语法规则判断，并在编译成字节码时应用这些规则。123456789##### 基本概念函数式接口。 如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口，只有函数式接口才能使用Lambda表达式进行简化。方法引用 ClassName:: MethodName InstanceName:MethodName ClassName::new123456789接口默认方法，在实现接口时就不需要实现Default方法```javapublic interface IDefaultMethod &#123; String getString(); default int getInt()&#123; return 1024; &#125;&#125; 编译器自动推导类型 接口类型 方法参数类型 方法返回值类型 如果不能推导出来那就需要开发者显示指出 二、java.util.function（java8功能性接口） java.util.function是java8中提供便于Lambda编程的接口，包内全部为接口api文档 主要分为 Consumer（泛型输入，无输出） Function（泛型输入，泛型输出） Predicate（泛型输入，Boolean输出） Supplier(无输入，泛型输出) UnaryOperator(一元操作，输入一个T，返回一个T，因为继承Function) BinaryOperator(二元操作，输入两个T，返回一个T，因为继承BiFunction) 三、java.util.stream 流是一种基于集合这种数据源产生的，可以在其上处理一系列操作的对象。 扩展阅读 http://lucida.me/blog/java-8-lambdas-insideout-language-features/ http://www.oschina.net/translate/everything-about-java-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA 内存模型]]></title>
      <url>%2F2016%2F11%2F18%2FProgramming-Summary%2FJAVA%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[1. 内存模型1.1 内存分类 虚拟机栈：每个线程有一个虚拟机栈，栈的空间有上限，达到上限会报stackoverflow异常。 Java Heap：java堆内存区域所有线程共享，所有对象和数组都在堆上进行分配内存，当申请不到空间时抛出OutOfMemoryError。 Java Heap具体又可以分为以下三个部分： 年轻代 Eden(空间不注意分配新对象就出发GC) Survivor 年老代 永久代 方法区：永久代是一种JVM规范，方法区是虚拟机对永久代的一种实现，一般存储类的信息，常量池，方法代码。 参考： http://www.cnblogs.com/paddix/p/5309550.html 2. GC策略TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RXJava]]></title>
      <url>%2F2016%2F11%2F16%2FProgramming-Summary%2FRXJava%2F</url>
      <content type="text"><![CDATA[RxJava generally consists of Observable (which emits the data which we can observe) and Observer (which observes emitted data and handles it). 1. 观察者模式 Observable：整理并提供数据、事件序列 Observer(Subscriber)：响应数据、事件序列 Subscribe：Observable subscribe (to) Observer 2. 变换3. 线程调度在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件 observeOn() 指定的是 Subscriber 的线程，所以指定的是它之后的操作所在的线程 subscribeOn() 指定的是第一个 Observable 的线程,subscribeOn() 的位置放在操作的前后都可以，但它是只能调用一次的。 相关网站 reactiveX官网 reactiveX WIKI ReactiveX/RxJava文档中文版 给Android开发者的RXJava详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Linux]]></title>
      <url>%2F2016%2F11%2F14%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8ELinux%2F</url>
      <content type="text"><![CDATA[Linux简介Linux 本身只是一个内核，它为程序员定义了操作系统的基本元素，但最终用户无法直接操作它也无法使用它。所以，除了开发者以外的用户，无法知道 Linux 是什么。 Linux 是一个相对自由的世界，所以围绕 Linux 内核你可以搭建出各种各样的上层系统。这样搭建起来的系统，称为「发行版」。普通用户只能接触到发行版，无法接触到 Linux 本身，而发行版中所带的命令行，shell，X Window 系统，都不属于 Linux 的一部分。 王垠曾经说过：Linux 可以是这样，Linux 可以是那样，Linux 可以是任何样子。 包管理工具 yum apt-get（Advanced Package Tool） rpm（Redhat Package Manager）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell基础]]></title>
      <url>%2F2016%2F11%2F12%2FProgramming-Summary%2FShell%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[1. Unix常用目录： http://www.ruanyifeng.com/blog/2012/02/a_history_of_unix_directory_structure.html https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard http://cnbin.github.io/blog/2015/06/05/mac-os-x-de-xi-tong-mu-lu-jie-gou/ 2. 关于 - &amp; – 的区别http://serverfault.com/questions/387935/whats-the-difference-betwen-the-single-dash-and-double-dash-flags-on-shell-comm 3. 命令格式command [options] [arguments]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell常用命令]]></title>
      <url>%2F2016%2F11%2F10%2FProgramming-Summary%2FShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[http://man.linuxde.net/ 1. 系统常用命令123456789101112131415161718uname -a 查看内核/操作系统/CPU信息head -n 1 /etc/issue 查看操作系统版本cat /proc/cpuinfo 查看CPU信息hostname 查看计算机名lspci -tv 列出所有PCI设备lsusb -tv 列出所有USB设备lsmod 列出加载的内核模块env 查看环境变量ipconfig getifaddR 获取IP地址mv FILE_A FILE_B 重命名FILE_Anohup some-command &amp; 后台运行some-commandwget -O some-file some-url 下载some-url到some-filetar -xvf filename.tar.gz 解压文件ln -s FILE_PATH LINK_PATH 创建软连接df -h 磁盘占用情况du -sh * 或者 du -ah --max-depth=1 当前目录下所有文件夹和文件的大小&lt;!--more--&gt;du -sh * | sort -h 根据大小排序文件/文件夹 2. 查找 grep find locate查找相关命令 find和grep的区别: find查找的文件的属性，grep查找的是文件的内容 find . -name &quot;*Dao*&quot; -exec rm -rf {} \; 查找当前目录所有文件名包含Dao的文件并将他们删除 3. 数据处理 awk sed4. 用户和权限管理4.1 用户和用户组 用户和用户组的关系可以是1.一对一 2.一对多 3.多对多 4.多对一 切换用户 su(switch user) username 4.2 新增1useradd username 添加用户 4.3 修改1passwd username 修改用户密码 4.4 查询 groups username 显示someUser所在组，可能有多个 在/etc/group 中的每条记录分四个字段： 12 _postgres:*:216:_devicemgr,_calendar,_teamsserver,_xserverdocs用户组名称：用户组密码：GID：用户列表 4.5 删除1userdel username 删除用户 权限管理 一个文档的所有者只能有一个用户 chmod&amp;chown命令 chown更改文档的属主，指定 有且只有一个用户。 chomod更改文件的权限，包括user（属主），group（与属主同一个用户组）， other（其他用户）对文件的rwx权限，7表示全部权限开通 123chmod a+x f01 对文件f01的u,g,o都设置可执行属性,a代表所有用户(u,g,o)sudo chown -R athrun:admin mysql/ 修改文件夹mysql和内部所有文件的所有者为用户athrun，用户组为admin（athrun不属于admin也是可以的） 5. 查看进程信息 lsof(list open files) ps ps -ef | grep nginx 查找和nginx有关系的进程列表 | :管道命令，将上个命令的输出作为下个命令的输入 以查看1099端口占用进程为例： 12lsof -i :1099ps -ef | grep 1099 终止相关进程 1sudo kill -9 PID 6. Java监控(jstat,jmap,jstack) 常规监控： 12jstat -gcutil pid //查看gc情况jstat -gcutil 23613 2000 出现瓶颈时监控： 12345jmap -heap pid // 查看堆内存使用情况jmap -histo pid //打印每个class的实例数目,内存占用,类全名jstack pid &gt; pid.txt //jvm 线程分析top -Hp pid //查看那个线程cpu高，将线程id 转成16进制 在 jstack 导出来的文本文件中查看这个线程在干嘛printf “%x”Tid //打印线程号的16进制 7. 远程文件传输方式一： 12scp scp.test root@172.16.10.4:/tmp/scp.test 从本地上传到远程服务器scp username@servername:/path/filename /tmp/local_destination 从远程下载文件到本地 方式二： 安装lrzsz，使用rz上传文件，sz下载文件TIPs:文件较大时使用rz -e 方式三：FTP 方式四： 使用ssh支持的sftp传输文件到服务器 vsftpd can support FTPS if configured, but sftp runs over ssh. 1.连接远程ftp服务器sftp root@202.206.64.33 2.拉取远程文件到本地sftp&gt; get /var/www/fuyatao/index.php /home/fuyatao/这条语句将从远程主机的 /var/www/fuyatao/目录下将 index.php 下载到本地 /home/fuyatao/目录下。 3.上传本地文件到远程sftp&gt; put /home/fuyatao/downloads/Linuxgl.pdf /var/www/fuyatao/这条语句将把本地 /home/fuyatao/downloads/目录下的 linuxgl.pdf文件上传至远程主机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim操作]]></title>
      <url>%2F2016%2F11%2F08%2FProgramming-Summary%2Fvim%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[1. 模式简介1. Normal 2. Insert 3. Visual 用v命令进入的字符可视化模式（Characterwise visual mode)。文本选择是以字符为单位的。 用V命令进入的行可视化模式（Linewise visual mode)。文本选择是以行为单位的。 用ctrl-V进入的块可视化模式（Blockwise visual mode）。可以选择一个矩形内的文本。（注意：在Windows中，ctrl-V可能已经被影射为粘贴操作，可以使用ctrl-Q进入块可视化模式。） 2. 复制粘贴操作yy复制游标所在行整行。或大写一个Y。 2yy或y2y复制两行。 y^复制至行首，或y0。不含游标所在处字元。 y$复制至行尾。含游标所在处字元。 yw复制一个word。 y2w复制两个字（单词）。 yG复制至档尾。 y1G复制至档首。 p小写p代表贴至游标后（下）。 P大写P代表贴至游标前（上）。 3. 删除命令ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本 4. 光标移动操作TODO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MACHINE LEARNING]]></title>
      <url>%2F2016%2F11%2F06%2FProgramming-Summary%2FMACHINE%20LEARNING%2F</url>
      <content type="text"><![CDATA[1. 学习方式 监督式学习 非监督式学习 半监督式学习 强化学习 2. 机器学习算法http://blog.jobbole.com/77620/ 2.1 分类算法2.1.1 决策树2.1.2 贝叶斯2.1.3 人工神经网络2.1.4 支持向量机SVM2.1.5 k-临近]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Phabricator]]></title>
      <url>%2F2016%2F11%2F02%2FProgramming-Summary%2FPhabricator%2F</url>
      <content type="text"><![CDATA[[TOC] 1. 简介 A complete software development platform Phabricator is an integrated set of powerful tools to help companies build higher quality software. 官网) 2. 安装(CentOS)nginx+php-fpm+phabricator git repo+MySql 安装脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#!/bin/bashconfirm() &#123; echo &quot;Press RETURN to continue, or ^C to cancel.&quot;; read -e ignored&#125;&lt;!--more--&gt;RHEL_VER_FILE=&quot;/etc/redhat-release&quot;if [[ ! -f $RHEL_VER_FILE ]]then echo &quot;It looks like you&apos;re not running a Red Hat-derived distribution.&quot; echo &quot;This script is intended to install Phabricator on RHEL-derived&quot; echo &quot;distributions such as RHEL, Fedora, CentOS, and Scientific Linux.&quot; echo &quot;Proceed with caution.&quot; confirmfiecho &quot;PHABRICATOR RED HAT DERIVATIVE INSTALLATION SCRIPT&quot;;echo &quot;This script will install Phabricator and all of its core dependencies.&quot;;echo &quot;Run it from the directory you want to install into.&quot;;echoRHEL_REGEX=&quot;release ([0-9]+)\.&quot;if [[ $(cat $RHEL_VER_FILE) =~ $RHEL_REGEX ]]then RHEL_MAJOR_VER=$&#123;BASH_REMATCH[1]&#125;else echo &quot;Ut oh, we were unable to determine your distribution&apos;s major&quot; echo &quot;version number. Please make sure you&apos;re running 6.0+ before&quot; echo &quot;proceeding.&quot; confirmfiif [[ $RHEL_MAJOR_VER &lt; 6 &amp;&amp; $RHEL_MAJOR_VER &gt; 0 ]]then echo &quot;** WARNING **&quot; echo &quot;A major version less than 6 was detected. Because of this,&quot; echo &quot;several needed dependencies are not available via default repos.&quot; echo &quot;Specifically, RHEL 5 does not have a PEAR package for php53-*.&quot; echo &quot;We will attempt to install it manually, for APC. Please be careful.&quot; confirmfiecho &quot;Phabricator will be installed to: $(pwd).&quot;;confirmecho &quot;Testing sudo/root...&quot;if [[ $EUID -ne 0 ]] # Check if we&apos;re root. If we are, continue.then sudo true SUDO=&quot;sudo&quot; if [[ $? -ne 0 ]] then echo &quot;ERROR: You must be able to sudo to run this script, or run it as root.&quot;; exit 1 fifiif [[ $RHEL_MAJOR_VER == 5 ]]then # RHEL 5&apos;s &quot;php&quot; package is actually 5.1. The &quot;php53&quot; package won&apos;t let us install php-pecl-apc. # (it tries to pull in php 5.1 stuff) ... yum repolist | grep -i epel if [ $? -ne 0 ]; then echo &quot;It doesn&apos;t look like you have the EPEL repo enabled. We are to add it&quot; echo &quot;for you, so that we can install git.&quot; $SUDO rpm -Uvh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm fi YUMCOMMAND=&quot;$SUDO yum install httpd git php53 php53-cli php53-mysql php53-process php53-devel php53-gd gcc wget make pcre-devel mysql-server&quot;else # RHEL 6+ defaults with php 5.3 YUMCOMMAND=&quot;$SUDO yum install httpd git php php-cli php-mysql php-process php-devel php-gd php-pecl-apc php-pecl-json php-mbstring mysql-server&quot;fiecho &quot;Dropping to yum to install dependencies...&quot;echo &quot;Running: $&#123;YUMCOMMAND&#125;&quot;echo &quot;Yum will prompt you with [Y/n] to continue installing.&quot;$YUMCOMMANDif [[ $? -ne 0 ]]then echo &quot;The yum command failed. Please fix the errors and re-run this script.&quot; exit 1fiif [[ $RHEL_MAJOR_VER == 5 ]]then # Now that we&apos;ve ensured all the devel packages required for pecl/apc are there, let&apos;s # set up PEAR, and install apc. echo &quot;Attempting to install PEAR&quot; wget http://pear.php.net/go-pear.phar $SUDO php go-pear.phar &amp;&amp; $SUDO pecl install apcfiif [[ $? -ne 0 ]]then echo &quot;The apc install failed. Continuing without APC, performance may be impacted.&quot;fipidof httpd 2&gt;&amp;1 &gt; /dev/nullif [[ $? -eq 0 ]]then echo &quot;If php was installed above, please run: /etc/init.d/httpd graceful&quot;else echo &quot;Please remember to start the httpd with: /etc/init.d/httpd start&quot;fipidof mysqld 2&gt;&amp;1 &gt; /dev/nullif [[ $? -ne 0 ]]then echo &quot;Please remember to start the mysql server: /etc/init.d/mysqld start&quot;ficonfirmif [[ ! -e libphutil ]]then git clone https://github.com/phacility/libphutil.gitelse (cd libphutil &amp;&amp; git pull --rebase)fiif [[ ! -e arcanist ]]then git clone https://github.com/phacility/arcanist.gitelse (cd arcanist &amp;&amp; git pull --rebase)fiif [[ ! -e phabricator ]]then git clone https://github.com/phacility/phabricator.gitelse (cd phabricator &amp;&amp; git pull --rebase)fiechoechoecho &quot;Install probably worked mostly correctly. Continue with the &apos;Configuration Guide&apos;:&quot;;echoecho &quot; https://secure.phabricator.com/book/phabricator/article/configuration_guide/&quot;; 3 配置(CentOS)3.1 nginx 配置123456789101112131415161718192021222324252627282930313233343536server &#123; listen 85; server_name pha.dev; root /usr/share/phabricator/phabricator/webroot; location / &#123; index index.php; rewrite ^/(.*)$ /index.php?__path__=/$1 last; &#125; location = /favicon.ico &#123; try_files $uri =204; &#125; location /index.php &#123; fastcgi_pass localhost:9000; fastcgi_index index.php; #required if PHP was built with --enable-force-cgi-redirect fastcgi_param REDIRECT_STATUS 200; #variables to make the $_SERVER populate in PHP fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; &#125;&#125; 3.2 配置MySQL./bin/storage upgrade 3.3 启动nginx/etc/init.d/nginx start 3.4 启动php-fpmetc/init.d/php-fpm start]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升开发效率的工具]]></title>
      <url>%2F2016%2F10%2F31%2FProgramming-Summary%2F%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Chrome 插件 postman 新浪微博图床 Adblock plus Scroll to top OneTab ColorZilla CapturePage 网页工具Mac其他 管理github工程 github star管理工具 github增强工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生成基于ant的构建脚本]]></title>
      <url>%2F2016%2F10%2F29%2FProgramming-Summary%2F%E7%94%9F%E6%88%90%E5%9F%BA%E4%BA%8Eant%E7%9A%84%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[android update project -p . 生成build.xml 标签简介 property定义一些全部字符串变量，如位置等 target 内部定义一连串的操作，达成的目标，是一个基本的执行单元，类似于方法 taskdef 定义一个任务，这个任务可以在其他地方座位标签被使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gradle]]></title>
      <url>%2F2016%2F10%2F27%2FProgramming-Summary%2FGradle%2F</url>
      <content type="text"><![CDATA[todohttp://blog.csdn.net/innost/article/details/48228651 1. 什么是GradleGradle is Groovy but more than Groovy 2. 基本概念一个project包含多个task project task 3. 基本语法创建一个task Gradle 123task helloWorld &lt;&lt; &#123; println &apos;helloWorld&apos;&#125; Groovy 123task(&quot;helloWorld&quot;).leftShift(&#123; println &apos;hello world&apos;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于构建工具]]></title>
      <url>%2F2016%2F10%2F25%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8E%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[一般而言.一个比较正规的项目都不会基于IDE进行构建.一般会用ant, maven, gradle. 实际上各种IDE 也是基于各种构建系统,也正是不同的IDE,它们的构建方式不同,所以要让不同的IDE间能一起开发,于是需要一个统一的构建工具. 一般c/c++ 项目用make,或者 premake. 而java 一般是ant,ivy,gradle,maven,还有直接的shell ###常用构建工具 Make Ant Maven Gradle]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python]]></title>
      <url>%2F2016%2F10%2F23%2FProgramming-Summary%2FPython%2F</url>
      <content type="text"><![CDATA[1. 安装1.1 环境MAC OS X EI Capitan(自带python2.7) 1.2 安装python3brew install python3 1.3 安装依赖(使用豆瓣源)pip install pythonModuleName -i https://pypi.douban.com/simple 1.4 依赖包路径 2. Hello Python]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F07%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
