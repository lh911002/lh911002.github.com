<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[工厂方法模式和抽象工厂模式]]></title>
      <url>%2F2017%2F08%2F09%2FProgramming-Summary%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1. 背景工厂方法模式和抽象工厂模式是23种设计模式中的两种创建型模式。 2. 为什么需要工厂模式 创建对象是一个谨慎的操作 创建对象可能需要一系列步骤 可能需要多个对象（相同产品族）协同工作 eg. 123IProduct a = new ProductA();IProduct b = new ProductA();IProduct c = new ProductA(); 如果要修改ProductA为ProductB，就需要修改3处 如果使用工厂方法 1234IFactory f = new FactoryA();IProduct a = f.createProduct();IProduct b = f.createProduct();IProduct c = f.createProduct(); 只需要扩展一个FactoryB即可，符合开闭原则 3. 工厂模式主要角色 抽象工厂对象 具体工厂对象 抽象产品对象 具体产品对象 3.1 工厂方法模式工厂方法模式具有一个抽象工厂类，一个抽象产品类； 优点：使用多态将对象的创建延迟到子类中，方便扩展；屏蔽了实例创建的细节； 缺点：在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类； 3.2 抽象工厂模式抽象工厂模式具有一个抽象工厂类，多个抽象产品类 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。 优点：使用多态将对象的创建延迟到子类中，方便扩展；屏蔽了实例创建的细节；针对一系列产品的创建提供了解决方式； 缺点：添加新种类的产品就要对抽象工厂接口进行扩展，同时对抽象工厂接口的所有子类进行修改； 4. 实例工厂模式实例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android滑动冲突场景分析]]></title>
      <url>%2F2017%2F02%2F11%2FProgramming-Summary%2FAndroid%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[1. 知识准备要解决滑动冲突的问题，首先需要了解触摸事件的传递。Android触摸事件的传递遵循自顶向下，自底向上的准则。首先，事件从最顶层（最外层）Activity/View通过dispatchTouchEvent(MotionEvent ev)方法向内层View传递，当传递到底层View（非ViewGroup）时候通过onTouchEvent(MotionEvent event)判断是否处理触摸事件，如果不消费，上层View就有机会消费；如果被消费，那么上层View将不再执行onTouchEvent(MotionEvent event)；另外，OnTouchListener.onTouch()优先于当前View的onTouchEvent方法执行。 from question on stackoverflow.com 2. 场景场景1. ScrollView（垂直滚动）内嵌ViewPager（水平滑动） 解决方法： 方法一： 在ScrollView的onInterceptTouchEvent方法中判断滑动的方向和距离，当判断水平滑动时取消拦截事件，返回false方法二： 当无法修改ScrollView的代码时，在ViewPager中通过getParent获取ScrollView对象，并调用requestDisallowInterceptTouchEvent方法禁用拦截事件 场景2. ViewPager（水平）内嵌套ViewPager（水平）（例如：Tab内嵌入Banner）解决方法： 方法一： 在内部ViewPager接受到事件时就调用requestDisallowInterceptTouchEvent方法禁用外部ViewPager的拦截事件机制。常见实现如下： 1234567891011public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_MOVE: getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: getParent().requestDisallowInterceptTouchEvent(false); break; &#125;&#125; 方法二： 在外部ViewPager中判断触摸区域是否在内部ViewPager内，如果在就在onInterceptTouchEvent返回false，将事件传递给内部ViewPager处理 3. 总结事件冲突的一般性情况就是事件被错误的View消费掉了，导致这种情况的原因大致可以分为两种： 被上层View拦截 被下层View消费 针对这两种情况以及并灵活使用下面的方法就可以解决大部分事件冲突的问题： 1234requestDisallowInterceptTouchEvent(boolean disallowIntercept) 禁用或者启用拦截事件的机制onInterceptTouchEvent(MotionEvent ev) 定义是否拦截事件的返回值onTouchEvent() 当前View事件处理OnTouchListener.onTouch() 当前View的触摸监听]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android自动构建]]></title>
      <url>%2F2017%2F01%2F09%2FProgramming-Summary%2FAndroid%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[1. 搭建环境1.1 开发环境安装以下组件并配置环境变量 CentOS release 6.5 (Final) 64bit git 2.10.0 Gradle 2.4 JDK 1.8 Android SDK Platform 23 Android Build Tools 23.0.02 Android Extras（Android support Library） TIPS： centos 64 bit 上buil-tools 中的aapt工具不能很好运行，需要安装 yum install libgcc.i686 yum install zlib.i686 yum install glibc.i686 … 组件也可以通过插件自动安装，为了便于以后管理，这里选择自己安装 1.2 第三方平台 coding.net 代码托管 蒲公英应用托管平台 2. 安装和配置Jenkins插件2.1 安装插件 jenkins 1.6 gradle plugin 1.25 2.2 插件配置进入系统管理-&gt;系统设置，并添加以下配置 3. Jenkins Job 配置3.1 源代码拉取 3.2 构建触发器30分钟一次 3.3 执行构建3.3.1 执行构建 3.3.2 构建后上传至蒲公英，并保存返回二维码 12345678910111213function jsonval &#123; temp=`echo $json | sed &apos;s/\\\\\//\//g&apos; | sed &apos;s/[&#123;&#125;]//g&apos; | awk -v k=&quot;text&quot; &apos;&#123;n=split($0,a,&quot;,&quot;); for (i=1; i&lt;=n; i++) print a[i]&#125;&apos; | sed &apos;s/\&quot;\:\&quot;/\|/g&apos; | sed &apos;s/[\,]/ /g&apos; | sed &apos;s/\&quot;//g&apos; | grep -w $responsekey` echo $&#123;temp##*|&#125;&#125;json=`curl -F &quot;file=@YOUR_APK_PATH&quot; -F &quot;uKey=YOUR_USER_KEY&quot; -F &quot;_api_key=YOUR_API_KEY&quot; http://www.pgyer.com/apiv1/app/upload`responsekey=&apos;appQRCodeURL&apos;responsevalue=`jsonval`rm -rf pgyermkdir pgyercd pgyercurrentDate=`date +%Y_%m_%d_%H_%M_%S`wget -O $currentDate.jpg $responsevalue 3.4 构建后存档 4. Android 项目配置创建local.properties放于根目录，并将sdk.dir配置为本地Android sdk目录 5. 构建取包查看图片扫码进入蒲公英下载页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AIDL简介]]></title>
      <url>%2F2017%2F01%2F07%2FProgramming-Summary%2FAIDL%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[AIDL（全称Android Interface Definition Language）是一种Android内部进程间通信的手段，其依赖Binder驱动实现进程间通信。 换句话说，AIDL是在Binder基础上进行的一轮封装，实际可以不使用AIDL，可以自定义相关组件进行进程间通信。 下面通过一个简单的例子对AIDL进行学习，例子包含一个客户端进程，一个服务端进程。 1. AIDL接口定义在服务端定义AIDL接口，然后复制到客户端，生成相同的Java代码。 aidl接口如下： 1234567891011121314// IMyAidlInterface.aidlpackage heng.liao.athrun.remote_app;// Declare any non-default types here with import statementsinterface IMyAidlInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); String getRuntimeString();&#125; 上面代码是定义了一个接口getRuntimeString的aidl文件，编译后会自动生成一个文件，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/athrun/code/github/Programming-Summary/Android/AIDL/app/src/main/aidl * /heng/liao/athrun/remote_app/IMyAidlInterface.aidl */package heng.liao.athrun.remote_app;// Declare any non-default types here with import statementspublic interface IMyAidlInterface extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements heng.liao.athrun .remote_app.IMyAidlInterface &#123; private static final java.lang.String DESCRIPTOR = &quot;heng.liao.athrun.remote_app&quot; + &quot;.IMyAidlInterface&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an heng.liao.athrun.remote_app.IMyAidlInterface interface, * generating a proxy if needed. */ public static heng.liao.athrun.remote_app.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof heng.liao.athrun.remote_app.IMyAidlInterface))) &#123; return ((heng.liao.athrun.remote_app.IMyAidlInterface) iin); &#125; return new heng.liao.athrun.remote_app.IMyAidlInterface.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0 != data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); java.lang.String _arg5; _arg5 = data.readString(); this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; case TRANSACTION_getRuntimeString: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.getRuntimeString(); reply.writeNoException(); reply.writeString(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements heng.liao.athrun.remote_app.IMyAidlInterface &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(anInt); _data.writeLong(aLong); _data.writeInt(((aBoolean) ? (1) : (0))); _data.writeFloat(aFloat); _data.writeDouble(aDouble); _data.writeString(aString); mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public java.lang.String getRuntimeString() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getRuntimeString, _data, _reply, 0); _reply.readException(); _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getRuntimeString = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException; public java.lang.String getRuntimeString() throws android.os.RemoteException;&#125; 生成的代码： IMyAidlInterface：接口，继承IInterface接口，并声明AIDL的接口 IMyAidlInterface.Stub：抽象类，继承Binder、IMyAidlInterface，不具体实现IMyAidlInterface，具体实现交给需要自定义Binder的地方，见下面的服务端代码就自己实现了一个Binder。asInterface在进行远程通信时会返回IMyAidlInterface.Stub.Proxy代理对象。 IMyAidlInterface.Stub.Proxy：实现IMyAidlInterface接口，通过调用远程方法mRemote.transact(Stub.TRANSACTION_getRuntimeString, _data, _reply, 0);实现接口。 如果是远程Binder，那么本地拿到的其实不是那个Binder，而是其代理BinderProxy对象，mRemote其实就是一个远程Binder对象（即BinderProxy） 2. 客户端客户端负责请求服务端数据，过程是获取远程对象的代理（BinderProxy对象实例），调用asInterface得到本地的IMyAidlInterface.Stub.Proxy并调用相关接口 asInterface也是binder hook的切入点，替换成自己的接口就能达到代理的目的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package heng.liao.athrun.aidldemo;import android.app.Activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.RemoteException;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.TextView;import heng.liao.athrun.remote_app.IMyAidlInterface;public class MainActivity extends Activity &#123; private TextView aidl_test; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); aidl_test = (TextView) findViewById(R.id.aidl_test); aidl_test.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; testAIDL(); &#125; &#125;); &#125; private void testAIDL() &#123; /*创建 ServiceConnection*/ ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IMyAidlInterface iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service); String result = &quot;result&quot;; try &#123; result = iMyAidlInterface.getRuntimeString(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); result = &quot;failed&quot;; &#125; aidl_test.setText(result); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; Intent intent = new Intent(&quot;heng.liao.athrun.remote_app.AIDLService&quot;); /*android 5.0以上必须显式指定*/ intent.setPackage(&quot;heng.liao.athrun.remote_app&quot;); bindService(intent,mServiceConnection, Context.BIND_AUTO_CREATE); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 3. 服务端提供客服端调用的接口服务，实现IMyAidlInterface.Stub，并重写Servcie的onBind()方法，返回自定义实现(binder本地对象)。 123456789101112131415161718192021222324252627282930313233343536package heng.liao.athrun.remote_app;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import java.util.Random;public class AIDLService extends Service &#123; private IBinder mBinder = new AIDLStubImpl(); private Random randomPro = new Random(); public AIDLService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; /*相当于自定义的IBinder类*/ class AIDLStubImpl extends IMyAidlInterface.Stub&#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; &#125; @Override public String getRuntimeString() throws RemoteException &#123; /*返回需要的运行时东西*/ return &quot;返回需要的运行时东西&quot;+randomPro.nextInt(100); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年回顾和2017年展望]]></title>
      <url>%2F2017%2F01%2F02%2FProgramming-Summary%2F2016%E5%B9%B4%E5%9B%9E%E9%A1%BE%E5%92%8C2017%E5%B9%B4%E5%B1%95%E6%9C%9B%2F</url>
      <content type="text"><![CDATA[毕业的时候是2014年7月份，今年已经2017，当把两个年份一比，才发觉工作至今已经差不多两年半的时间，不知不觉已经不再是刚毕业时候初出茅庐的自己了，16年已经过去了，记录一下这一年的成长和教训，也对2017年的自己作一些期许和要求。 2016年回顾毕业后到2015年底都一直在做Android开发，可能是自己对编程的喜好和公司情况导致，2016年在公司内部转岗多次，先做了五个月后台，然后做了五个月Android开发，再然后就是Web前端开发，目前还在处理公司一些前端开发的工作，差不多两三个月了吧。 每次转岗都意味着需要学习大量的知识，经验的积累也需要一定时间，遇到复杂问题无法解决，这是转岗的痛点。好处也很明显，考虑问题时候往往可以跳出自己所处的位置去思考，也意味着找到更周全的解决方案的可能性更大。 这一年还用python写了一些脚本，为什么选择python，因为人生苦短，我用python。 对于这一年，自己稍显浮躁。势必需要静下心，仔细思考以后的路，重视自己的每个选择，慎重。一门技术学会不难，学透很难，2017年希望自己可以更专注。 2017年展望目标的达成离不开每一天的努力，一切都是身外之物，好的品性才能让自己受益终生。 2017年，做个五讲四美好青年 更努力，每天都不要浪费。 更严格，当我可以做的更好，我为什么不做的更好？ 更深刻，思考的广度、深度、角度。 更无畏，做个勇敢的人。 更健康，每天都要锻炼。 不急躁，不忙不慌的，因为你知道那样于事无补；很多美好只有你变慢的时候才能展现出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常见问题以及解决]]></title>
      <url>%2F2017%2F01%2F01%2FProgramming-Summary%2FAndroid%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[Android开发中总会遇到很多问题，其中的一些问题在解决中会发现，这些问题没有准确的报错信息，或者不方便调试，千辛万苦找到问题解决方法，以后再遇到还有可能忘记。所以，在这里对自己遇到的一些问题做一个记录。 NO.1 问题描述：home键或者其他方式程序进入后台后，一段时间回到前台界面显示信息出错 原因分析：由于app进入后台时间太久没有唤起，被系统回收 问题解决：在application类的onCreate方法里面对重新启动进行监听并重新启动进入后台时候的Activity NO.2 问题描述：postDelay+Dialog引起的窗体泄露 原因分析：Android中消息队列postDelay+Dialog引起的窗体泄露的主要原因是，当床窗体压入栈或者finish掉后，Activity由于需要处理postDelay而不能及时销毁，因此造成了一个问题，当dialog触发show方法时，由于window和activity已经分开了，因此便会造成窗体泄露。 问题解决：通过对Activity的状态进行监听确定是否显示dialog，见代码 12345678910111213141516171819202122232425262728private boolean isActive = true;public void onResume()&#123; super.onResume(); isActive = true;&#125;public void onPause()&#123; super.onPause(); isActive = false;&#125; public boolean activityIsActivity()&#123; return isActive;&#125; public void showAlertDialog()&#123; if(activityIsActive()) //只有窗体处于活动状态时执行此程序 &#123; AlertDialog.Builder builder = new AlertDialog.Builder(activity); builder.setTitle("hello world") .setCancelable(false) .setMessage("Hello"); builder.create().show(); &#125;&#125; NO.3 混淆填坑记 问题描述：集成某第三方SDK后（这也是后来才发现），一堆jar包，生产包打不出来，测试包可以。 原因分析：初步定位为混淆问题，查看jenkins失败日志，确定确实是混淆出错，发现类似如下日志： 1234Warning: org.bouncycastle.mail.smime.handlers.PKCS7ContentHandler: can&apos;t find referenced class java.awt.datatransfer.DataFlavorWarning: org.bouncycastle.mail.smime.handlers.PKCS7ContentHandler: can&apos;t find referenced class java.awt.datatransfer.DataFlavorWarning: org.bouncycastle.mail.smime.handlers.PKCS7ContentHandler: can&apos;t find referenced class java.awt.datatransfer.DataFlavorWarning: org.bouncycastle.mail.smime.handlers.PKCS7ContentHandler: can&apos;t find referenced class java.awt.datatransfer.DataFlavor 通过PKCS7ContentHandler定位到新集成的SDK，发现新SDK的集成文档中关于混淆的规则出现缺失，确实的就是org.bouncycastle包的内容。 问题解决：在proguard-rules.pro文件中添加 12-keep class org.bouncycastle.** &#123;*;&#125;-dontwarn org.bouncycastle.**]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android分辨率兼容]]></title>
      <url>%2F2016%2F12%2F30%2FProgramming-Summary%2FAndroid%E5%88%86%E8%BE%A8%E7%8E%87%E5%85%BC%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[1. 相关概念 PX:像素点,图片的尺寸 PT:1/72 inch，物理单位1inch＝2.54cm DPI(Dots per inch):每个英寸(物理单位)的px数。 DP(DIP,Density-independent Pixels):DP是人为规定的一个单位。官方文档中解释one DIP is one pixel on an approximately 160 dpi screen (for example a 240x320, 1.5”x2” screen),所以在320dpi的设备上，1DIP = 2PX,以此类推。 SP(Scale-independent Pixels) 总结: android.util.DisplayMetricsd源码中的density是DP和PX转换的因子，公式为$$PX = density * DP$$,而$$density = 当前设备的DPI/160$$ 所以说，在160DPI(即每个英寸有160个像素点)的设备上，density 是1，代表每个DP包含1个像素，在320DPI设备上density是2，代表每个DP包含2个像素。 最终的公式是：$$PX = {DPI * DP \over 160} $$ 因为DPI是由设备决定的，而现在主流的设备也是相差不多，比如1080P的DPI一般就是5inch,那么DPI就是440，density为2.75，那么屏幕的宽度1080px ＝ 1080/2.75 ＝ 392dp。 二.适配方案 首先，保证长度单位均使用DP作为单位（特殊情况，如根据屏幕分辨率动态设置除外）,同时使用灵活的自适应布局风格，还可以利用LineaLayout的weight对布局进行比例分割。 根据不同分辨率，取不同的drawable和dimen，而layout则使用一套。比如设计师给到一张在1080P手机上100x100的切图，那么在480x800手机上就应该进行缩小，理论上是一半，实际上还需要根据真机做调整。 文件夹 DPI ldpi 0-120 mdpi 120-160 hdpi 160-240 xhdpi 240-320 xxhdpi 320-480 123456res/drawable (default)res/drawable-ldpi/ (240x320 and nearer resolution)res/drawable-mdpi/ (320x480 and nearer resolution)res/drawable-hdpi/ (480x800, 540x960 and nearer resolution)res/drawable-xhdpi/ (720x1280 - Samsung S3, Micromax Canvas HD etc)res/drawable-xxhdpi/ (1080x1920 - Samsung S4, HTC one, Nexus 5, etc) 123456res/values/dimens.xml(default)res/values-ldpi/dimens.xml (240x320 and nearer resolution)res/values-mdpi/dimens.xml (320x480 and nearer resolution)res/values-hdpi/dimens.xml (480x800, 540x960 and nearer resolution)res/values-xhdpi/dimens.xml (720x1280 - Samsung S3, Micromax Canvas HD, etc) res/values-xxhdpi/dimens.xml (1080x1920 - Samsung S4, HTC one, etc)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态代理]]></title>
      <url>%2F2016%2F12%2F28%2FProgramming-Summary%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[Java动态代理是Java比较常见的一种设计模式，其能够实现得益于java的多态特性；动态代理广泛应用于AOP（切面编程）。 1. 代理的概念：代理中参与的角色如下图： 图中A是调用者，B是代理类，C是委托类，也称作被代理类。委托类实现具体方法。 2. 动态代理动态代理主要有两种： 基于接口的JDK动态代理（主要依赖反射） 基于字节码的动态代理（主要依赖CGLib对字节码操作） 2.1 基于接口的动态代理相关组件关系： 动态代理实现步骤: 创建委托类Operate接口和实现类OperateImpl 自定义中间类实现InvocationHandler接口方法bject invoke(Object proxy, Method method, Object[] args) throws Throwable;,InvocationHandler是中间类，在自动生成的代理类中会调用invoke方法，把接口的Method和参数传递过来，在invoke中使用OperateImpl的实例调用Method实现调用委托类。invoke的实现和具体委托类的方法无关，通过反射调用相关方法，method.invoke(target, args);。 调用(Operate)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler)方法生成代理类实例，代理类已经实现委托类Operate接口，直接使用代理类实例的方法就可以调用委托类Operate的方法了。 调用链： 调用Proxy类的Operate接口 调用InvocationHandler的invoke方法，并传递Method实例和参数 在invoke内通过反射调用委托类实例的Method方法达到代理的目的 动态代理区别于静态代理之处就在于被代理类需要实现接口，如果没有接口，那就只能使用静态代理去代理了。 参考： 1.http://www.infoq.com/cn/articles/cf-java-reflection-dynamic-proxy2.http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86 2.2 基于字节码CGLib的动态代理cglib的一个简单例子： 1234567891011121314151617181920212223242526272829303132333435public class Target&#123; public void f()&#123; System.out.println("Target f()"); &#125; public void g()&#123; System.out.println("Target g()"); &#125;&#125;public class Interceptor implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("I am intercept begin");//Note: 此处一定要使用proxy的invokeSuper方法来调用目标类的方法 proxy.invokeSuper(obj, args); System.out.println("I am intercept end"); return null; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "F:\\code"); //实例化一个增强器，也就是cglib中的一个class generator Enhancer eh = new Enhancer(); //设置目标类 eh.setSuperclass(Target.class); // 设置拦截对象 eh.setCallback(new Interceptor()); // 生成代理类并返回一个实例 Target t = (Target) eh.create(); t.f(); t.g(); &#125;&#125; 通过代码我们能看出cglib的动态代理相对于jdk的动态代理有个优点就是不需要委托类实现指定接口，而是通过代理类继承委托类实现代理，所以不能对final类进行动态代理。 3. 实例http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android多渠道打包]]></title>
      <url>%2F2016%2F12%2F22%2FProgramming-Summary%2FAndroid%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[1. 背景Android应用分发因为没有一个统一的APP Store，为了统计各种应用商店的安装和推广效果，需要在包内添加渠道信息。 2. 原理该打包工具参考了美团的打包方案。由于apk压缩文件的META-INF目录下文件不影响签名结果，所以可以在打包签名后在META-INF目录下生成相应的渠道标记，在程序运行时通过程序代码读取打包渠道号即可设置渠道。 3. 使用方法 在marketlist.txt文件中配置渠道列表 运行build.py（需安装python运行环境） 4. Python脚本代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import osimport shutilimport zipfile# 空文件 便于写入此空文件到apk包中作为channel文件src_empty_file = 'temp.txt'# 创建一个空文件（不存在则创建）f = open(src_empty_file, 'w') f.close()# 获取渠道列表channel_file = 'marketlist.txt'f = open(channel_file)lines = f.readlines()f.close()# 获取当前目录中所有的apk源包src_apks = []for file in os.listdir(): if os.path.isfile(file): extension = os.path.splitext(file)[1][1:] if extension in 'apk': src_apks.append(file) # file name (with extension)src_apk = src_apks[0]src_apk_file_name = os.path.basename(src_apk)# 分割文件名与后缀temp_list = os.path.splitext(src_apk_file_name)# name without extensionsrc_apk_name = temp_list[0]# 后缀名，包含. 例如: ".apk "src_apk_extension = temp_list[1]# 创建生成目录,与文件名相关output_dir = src_apk_name +"各渠道包"+ '/'# 目录不存在则创建if not os.path.exists(output_dir): os.mkdir(output_dir)# 遍历渠道号并创建对应渠道号的apk文件linesIndex = 1for line in lines: # 获取当前渠道号，因为从渠道文件中获得带有\n,所有strip一下 target_channel = line.strip() if "#" in line[0:1] : print("渠道"+target_channel[1:]+"跳过") continue # 拼接对应渠道号的apk target_apk = output_dir + src_apk_name + "_" + target_channel + src_apk_extension # 拷贝建立新apk shutil.copy(src_apk, target_apk) # zip获取新建立的apk文件 zipped = zipfile.ZipFile(target_apk, 'a', zipfile.ZIP_DEFLATED) # 初始化渠道信息 empty_channel_file = "META-INF/kdlcchannel_"+target_channel # 写入渠道信息 zipped.write(src_empty_file, empty_channel_file) # 关闭zip流 zipped.close() print(linesIndex,".渠道 "+target_channel+" 打包完成") linesIndex = linesIndex + 1 5. Android获取渠道号的代码12345678910111213141516171819202122232425262728293031323334public static String getAppChannel(Context context)&#123; ApplicationInfo appinfo = context.getApplicationInfo(); String sourceDir = appinfo.sourceDir; String ret = ""; ZipFile zipfile = null; try &#123; zipfile = new ZipFile(sourceDir); Enumeration&lt;?&gt; entries = zipfile.entries(); while (entries.hasMoreElements()) &#123; ZipEntry entry = ((ZipEntry) entries.nextElement()); String entryName = entry.getName(); if (entryName.startsWith("META-INF/kdlcchannel")) &#123; ret = entryName; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (zipfile != null) &#123; try &#123; zipfile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; String[] split = ret.split("_"); if (split != null &amp;&amp; split.length &gt;= 2) &#123; return ret.substring(split[0].length() + 1); &#125; else &#123; return "MarketNotSet"; &#125; &#125; 关于 APK Signature Scheme v2Android 7.0 引入 Scheme v2 导致这种多渠道打包失败，比较快捷的解决帮办法是在build文件中禁用V2版本签名，继续使用V1版本签名，但这并不是长久之计，彻底的解决方法参考美团新一代渠道包生成工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2016%2F12%2F14%2FProgramming-Summary%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[主要介绍常用的一些git命令 基础命令 12git add 命令（多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等） git status 命令，用来查看发生变动的文件。 查看提交1234git log 查看commit的历史git show &lt;commit-hash-id&gt; 查看某次commit的修改内容git log -p &lt;filename&gt; 查看某个文件的修改历史git log -p -2 查看最近2次的更新内容 分支管理123456git branch --track experimental origin/experimental 拉取并追踪分支 git branch -d &lt;branch_name&gt; 删除本地分支 git push origin --delete branch_3.0_liaoheng 删除远程分支git branch -vv 查看本地分支和远程分支的跟踪关联关系 git checkout -b myfeature 以当前分支为基础创建新分支git branch --set-upstream-to=origin/branch_3.0_liaoheng branch_3.0_liaoheng 将本地分支与远程分支关联 切换git源：1234git remote remove origingit remote add origin https://xxxx.git 将本地库添加到远程git push -u origin --all # pushes up the repo and its refs for the first time 上传所有文件git push -u origin --tags # pushes up any tags 标签管理123456git tag -a v1.1.4 -m &quot;tagging version 1.1.4&quot; #打标签git tag #列出标签git push --tags 推送所有本地标签到远程仓库git push 仓库名 标签名 eg. git push origin v1.0 推送本地标签到远程仓库git push origin --delete tag &lt;tagname&gt; 删除远程taggit tag -d v1.1.4 删除本地仓库标签 回滚（reset &amp;&amp; revert） git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 参考：http://samael65535.github.io/git/2013/01/18/git/ http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html 12HEAD 最近一个提交HEAD^ = HEAD^1 上一次 reset: 直接回退，将repository的版本进行回退，工作区的状态会根据参数不同有不同的结果 1git reset HEAD^1 将分支的HEAD指针指向倒数第二个提交（默认mixed策略，即保留工作区代码，不保留仓库和暂存区内容，如果要重新提交，需要执行git add .） revert：以新提交覆盖旧的提交达到回退的目的，如果修改已经不是最新的commit，则只能使用git revert。 12git revert HEAD 撤销最近的一次提交git revert HEAD^1 撤销倒数第二条提交（倒数第一条不撤销），通过产生一个commit覆盖倒数第二条commit，但是不会覆盖最新的一条（倒数第一条） 其他git ls-files –stage 显示index文件（.git目录下） 内容，即暂存区信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于git版本控制协议一些理解]]></title>
      <url>%2F2016%2F12%2F12%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8Egit%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[引用（即指针）对于理解git非常重要，git的分支、tag只是指向了不同commit的指针，不是实际文件. git版本控制协议结构图 关于暂存区的理解 1.图中index就是stage状态(暂存区)，index保存的是当前所有文件最新的git对象对应的hash值，使用commit命令后会将这些最新的状态提交到head中，head保存的就是该分支所有文件最新的状态，属于git仓库信息 2.Git index 可以看作是工作目录和Git库目录之间的暂存区，暂存区（stage或者叫index） 存储的是整个文件，如果文件修改add到暂存区，那么就会覆盖文件的上个版本，所以一定不会发生冲突 3.切换分支前要把修改的未提交的内容提交，不然切换分支后修改内容在另一个分支上任然可见，这样提交的时候就会有不需要的内容被提交（stash可以解决这个问题）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义UI-座位图]]></title>
      <url>%2F2016%2F12%2F10%2FProgramming-Summary%2F%E8%87%AA%E5%AE%9A%E4%B9%89UI-%E5%BA%A7%E4%BD%8D%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[1. 效果图 2. 技术细节 触摸事件处理 绘制坐标更新 放大缩小中心坐标计算 … 3. 代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode题解-数组类]]></title>
      <url>%2F2016%2F12%2F09%2FProgramming-Summary%2FLeetCode%E9%A2%98%E8%A7%A3-%E6%95%B0%E7%BB%84%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[[TOC] 1. Intersection of Two Arrays1.1 解题思路使用hash比较是否存在，实现时间复杂度O(n),坏处是空间复杂度也达到O(n). 1.2 代码 1234567891011121314151617181920212223public int[] intersection(int[] nums1, int[] nums2) &#123; HashSet&lt;Integer&gt; resultSet = new HashSet&lt;Integer&gt;(); if(nums1 == null || nums2 == null || nums1.length * nums2.length == 0)&#123; return new int[0]; &#125; HashSet&lt;Integer&gt; temp = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; nums1.length; i++) &#123; temp.add(nums1[i]); &#125; for (int i = 0; i &lt; nums2.length; i++) &#123; if(temp.contains(nums2[i]))&#123; resultSet.add(nums2[i]); &#125; &#125; int[] result = new int[resultSet.size()]; Iterator&lt;Integer&gt; iterator = resultSet.iterator(); for (int i = 0; i &lt; result.length; i++) &#123; result[i] = iterator.next(); &#125; return result; &#125; 2. Intersection of Two Arrays II2.1 解题思路本题在题1的基础上要求重复多少次就要在结果中出现多少次，采用了比较直接的解法，使用hashmap记录值和出现的次数 2.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041if(nums1 == null || nums2 == null || nums1.length * nums2.length == 0)&#123; return new int[0]; &#125; HashMap&lt;Integer,Integer&gt; resultMap = new HashMap&lt;Integer, Integer&gt;(); HashMap&lt;Integer,Integer&gt; nums1Map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums1.length; i++) &#123; nums1Map.put(nums1[i],nums1Map.get(nums1[i]) == null ? 1: nums1Map.get(nums1[i]) + 1); &#125; for (int i = 0; i &lt; nums2.length; i++) &#123; if(nums1Map.containsKey(nums2[i]))&#123; if(nums1Map.get(nums2[i]) == 1)&#123; nums1Map.remove(nums2[i]); &#125;else&#123; nums1Map.put(nums2[i],nums1Map.get(nums2[i]) - 1); &#125; resultMap.put(nums2[i],resultMap.get(nums2[i]) == null ? 1: resultMap.get(nums2[i]) + 1); &#125; &#125; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); Iterator iter = resultMap.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Integer key = (Integer) entry.getKey(); Integer val = (Integer) entry.getValue(); for (int i = 0; i &lt; val; i++) &#123; result.add(key); &#125; &#125; if(result.size() == 0)&#123; return new int[0]; &#125;else&#123; int[] resultArray = new int[result.size()]; for (int i = 0; i &lt; result.size(); i++) &#123; resultArray[i] = result.get(i); &#125; return resultArray; &#125; 3. First Missing Positive3.1 原题 Given an unsorted integer array, find the first missing positive integer. For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 3.2 解题思路拿到题目，看到O(n)时间第一反应就是空间换时间，但是看到后面要求空间复杂度O(1)的要求，才发现自己too young了;要在常数空间解决这个问题，首先想到的就是在原数组上都手脚，数组的索引对于解决问题具有很好的效果，可以从如何利用索引这个方向思考（算法题就是如此，思考可能的方向，一个方向想不通就换个方向思考），如果能把数组中值在索引范围内的元素放到对应索引位置，那么剩下的索引位置就是缺的元素；因为值要从1开始，所以索引0位置对应的值应为1，索引1位置对应值1。 3.3 实现代码12345678910111213141516171819202122232425262728public static int firstMissingPositive(int[] nums) &#123; if(nums == null || nums.length == 0) return 1; int temp = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &lt;= nums.length &amp;&amp; nums[i] &gt; 0)&#123;//当前值可以找到位置 if(nums[nums[i]-1] != nums[i])&#123;//要替换的位置是否已经有合适的值,没有才替换 temp = nums[nums[i]-1]; nums[nums[i]-1] = nums[i]; nums[i] = temp; i--;//执行过一次替换后需要把当前值再做处理 &#125; &#125; &#125; int result = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] != i+1)&#123; result = i+1; break; &#125; &#125; if(result == 0)&#123; result = nums.length + 1; &#125; return result; &#125; 4 Teemo Attacking4.1 解题思路采用比较直接的方法，遍历数组，如果上次中毒时间结束时间小于当前时间，则加上duration，否则减去重叠部分的时间，时间复杂度O(n),空间复杂度O(1). 4.2 实现代码12345678910111213int totalTime = 0;int lastPosionEnd = 0;for (int i = 0; i &lt; timeSeries.length; i++) &#123; int time = timeSeries[i]; if(lastPosionEnd == 0 || lastPosionEnd &lt; time)&#123; lastPosionEnd = time + duration; totalTime += duration; &#125;else&#123; lastPosionEnd = time + duration; totalTime += (time - timeSeries[i-1]); &#125;&#125;return totalTime;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Java的锁机制]]></title>
      <url>%2F2016%2F11%2F28%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8EJava%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[在处理多进程（线程）环境下的临界区访问问题时候需要引入锁机制。 1. CAS操作在介绍锁之前需要介绍一下CAS的概念，CAS是单词compare and set的缩写，意思是指在set之前先比较该值有没有变化（expect的值），只有在没变的情况下才对其赋值（update的值）。 在java中的实现： 123public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update);&#125; unsafe.compareAndSwapObject调用的是native方法 关于原子操作 2. 锁的种类锁的种类有很多，常见的分为以下几种： 2.1. 自旋锁获取锁的时候循环执行CAS(compareAndSet)，直到获取锁。 由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间短。适合使用自旋锁。 2.2. 阻塞锁顾名思义，在获取锁时使当前线程进入阻塞状态，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。 JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpart()。 在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。 2.3. 可重入锁（递归锁）指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。 如果是自旋锁，在重入时就会进入无限循环，所以自旋锁是不可重入锁。 ReentrantLock 和synchronized 都是 可重入锁. 可重入锁最大的作用是避免死锁. 2.4 悲观锁和乐观锁悲观锁(Pessimistic Lock)： 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock)：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。 2.5 公平锁和非公平锁公平锁：每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁。 非公平锁：每个线程抢占锁的顺序不定，谁运气好，谁就获取到锁，和调用lock方法的先后顺序无关。 3 Java中锁的实现 循环CAS(compareAndSet缩写)实现自旋锁 1234567891011121314public class SpinLock &#123; private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;(); public void lock()&#123; Thread current = Thread.currentThread(); while(!sign .compareAndSet(null, current))&#123; &#125; &#125; public void unlock ()&#123; Thread current = Thread.currentThread(); sign .compareAndSet(current, null); &#125;&#125; 使用synchronized和wait notify实现锁 12345678910111213public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; //不用if，而用while，是为了防止假唤醒 wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false; notify(); &#125;&#125; 使用方法 12345678910public class Counter&#123; private Lock lock = new Lock(); private int count = 0; public int inc()&#123; lock.lock(); this.count++; lock.unlock(); return count; &#125;&#125; 4. synchronized5. wait,notify,sleep wait和notify都是释放锁，sleep不释放 synchronized()的代码块中运行完就释放锁了 wait和notify必须先获得唯一控制权，一般用加锁实现 6. 锁的应用6.1. 阻塞队列借助Lock实现 参考 深入JVM锁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Support Library]]></title>
      <url>%2F2016%2F11%2F26%2FProgramming-Summary%2FAndroid%20Support%20Library%2F</url>
      <content type="text"><![CDATA[主要分类 包名 用途 API级别 v4 Support Library 最基础的library，包含多方面的代码 4(1.6) v7 Support Library 有多个子包，比如MD的一些UI组件，调色板工具等 7(2.1) v8 Support Library RenderScript 高性能计算 8 v13 Support Library 更多的Fragment支持 13(3.2) v14 Support Library 配置列表支持 14 |v17 Support Library| for TV |17||Multidex Support Library| 解决65536方法数限制 |-||Annotations Support Library| 注解库 |-||Design Support Library| MD组件支持 |-||Custom tabs Support Library| 自定义Tab页面|-||Percent Support Library| 百分比UI |-||App Recommendation Support Library|for TV|-| 详见官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java引用的分类]]></title>
      <url>%2F2016%2F11%2F25%2FProgramming-Summary%2FJava%E5%BC%95%E7%94%A8%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[分类java中的引用分为4类，具体区别：(以上讨论的回收时机都是在引用还存在的前提下) 级别 回收时机 创建方式 强引用 只要强引用还存在，就不回收 new 软引用 内存不足才会被回收 SoftReference 弱引用 被GC发现就回收，即使内存还充足 WeakReference 虚引用|任何时候回收|PhantomReference 用途 在Android中使用WeakReference保存Fragment对象实例，内存不足时回收页面，在需要时再创建。 …]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO]]></title>
      <url>%2F2016%2F11%2F22%2FProgramming-Summary%2FIO%2F</url>
      <content type="text"><![CDATA[1. IO首先看一下类继承关系 命名规则其实就是 操作对象 + 读写方式 字节流不需要处理编码，字节流和字符流转换才需要处理编码 1.1 IO的要素 内存（缓冲区） 流（通道） 操作对象 1.2 操作对象 byte[]对象 String对象 File对象 套接字 1.3 方向 Input/Reader:从对象到内存 Output/Writer:从内存到对象 1.4 读写方式 字节(InputStream/OutputStream)：一次读取一个字节 字符(Reader/Writer)：其实字符流可以看做是一种包装流，它的底层还是采用字节流来读取字节 1.5 特性 Streams one byte at a time. Good for binary data.byte oriented stream (8 bit)good for binary data such as a Java .class filegood for “machine-oriented” data Readers/Writers one character at a time. Good for text data.char (utf-16) oriented stream (16 bit)good for text such as a Java sourcegood for “human-oriented” data Buffered many bytes/characters at a time. Good almost all the time. 1.6 编码问题http://wiki.jikexueyuan.com/project/java-chinese-garbled-solution/ http://cenalulu.github.io/linux/character-encoding/ java运行时的默认编码可以通过Charset.defaultCharset()获取，其实质是获取当前系统的编码格式，如果系统没有设置，就是UTF-8，一般都会有设置。 编码发生在字节和字符的转化过程中,见下图 HTTP协议中，在Header里指定字符集，在客户端根据指定字符集将body里的内容（字节数组）解码成相应字符（如字符串） 对于String本身和字符集并无关系，字符集只在编码和解码的过程中发挥作用，他会对编码和解码的结果产生影响。 12字节-&gt;字符: 解码（指定字符集）字符-&gt;字节: 编码（指定字符集） 2. NIO 传统流I/O是基于字节的，所有I/O都被视为单个字节的移动；而NIO是基于块的，大家可能猜到了，NIO的性能肯定优于流I/O 2.1 相关概念 缓冲区 通道 内存映射文件：一次数据拷贝和两次数据拷贝的区别 异步IO 参考：http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lambda表达式]]></title>
      <url>%2F2016%2F11%2F20%2FProgramming-Summary%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Outline Lambda定义和结构 java.util.function（java8功能性接口） java.util.stream（java8流式接口） 一、Lambda定义和结构 Lambda表达式的定义：Java8引入Lambda表达式的目的是简化内部类的使用，其实质仍然是一个函数或者接口的实现。 虽然称作Lambda表达式，但是不同于一般的可计算的表达式，Lambda表达式是一个接口（函数）的实现，也可以理解成匿名类的缩写。 注：对于一个接口如果有多个未实现的方法，则不能使用Lambda表达式，可以有default和static方法方法 基本结构：( 形式参数 ) -&gt; { 方法实现 } 形式参数的参数类型可以省去，编译器可以自动判断e.g.1Collections.sort(list, (x, y) -&gt; y - x) 上面代码中的Lambda表达式：(x, y) -&gt; y - x 实现的就是 java.util.Comparator 接口的compare(T o1, T o2);```方法，虽然代码中没有显式指明，但是编译器会自动根据语法规则判断，并在编译成字节码时应用这些规则。123456789##### 基本概念函数式接口。 如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口，只有函数式接口才能使用Lambda表达式进行简化。方法引用 ClassName:: MethodName InstanceName:MethodName ClassName::new123456789接口默认方法，在实现接口时就不需要实现Default方法```javapublic interface IDefaultMethod &#123; String getString(); default int getInt()&#123; return 1024; &#125;&#125; 编译器自动推导类型 接口类型 方法参数类型 方法返回值类型 如果不能推导出来那就需要开发者显示指出 二、java.util.function（java8功能性接口） java.util.function是java8中提供便于Lambda编程的接口，包内全部为接口api文档 主要分为 Consumer（泛型输入，无输出） Function（泛型输入，泛型输出） Predicate（泛型输入，Boolean输出） Supplier(无输入，泛型输出) UnaryOperator(一元操作，输入一个T，返回一个T，因为继承Function) BinaryOperator(二元操作，输入两个T，返回一个T，因为继承BiFunction) 三、java.util.stream 流是一种基于集合这种数据源产生的，可以在其上处理一系列操作的对象。 扩展阅读 http://lucida.me/blog/java-8-lambdas-insideout-language-features/ http://www.oschina.net/translate/everything-about-java-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell常用命令]]></title>
      <url>%2F2016%2F11%2F10%2FProgramming-Summary%2FShell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[1. 系统常用命令123456789101112131415161718uname -a 查看内核/操作系统/CPU信息head -n 1 /etc/issue 查看操作系统版本cat /proc/cpuinfo 查看CPU信息hostname 查看计算机名lspci -tv 列出所有PCI设备lsusb -tv 列出所有USB设备&lt;!--more--&gt;lsmod 列出加载的内核模块env 查看环境变量ipconfig getifaddR 获取IP地址mv FILE_A FILE_B 重命名FILE_Anohup some-command &amp; 后台运行some-commandwget -O some-file some-url 下载some-url到some-filetar -xvf filename.tar.gz 解压文件ln -s FILE_PATH LINK_PATH 创建软连接df -h 磁盘占用情况du -sh * 或者 du -ah --max-depth=1 当前目录下所有文件夹和文件的大小du -sh * | sort -h 根据大小排序文件/文件夹 2. 查找 grep find locate查找相关命令 find和grep的区别: find查找的文件的属性，grep查找的是文件的内容 find . -name &quot;*Dao*&quot; -exec rm -rf {} \; 查找当前目录所有文件名包含Dao的文件并将他们删除 3. 数据处理 awk sed4. 用户和权限管理4.1 用户和用户组 用户和用户组的关系可以是1.一对一 2.一对多 3.多对多 4.多对一 切换用户 su(switch user) username 4.2 新增1useradd username 添加用户 4.3 修改1passwd username 修改用户密码 4.4 查询 groups username 显示someUser所在组，可能有多个 在/etc/group 中的每条记录分四个字段： 12 _postgres:*:216:_devicemgr,_calendar,_teamsserver,_xserverdocs用户组名称：用户组密码：GID：用户列表 4.5 删除1userdel username 删除用户 权限管理 一个文档的所有者只能有一个用户 chmod&amp;chown命令 chown更改文档的属主，指定 有且只有一个用户。 chomod更改文件的权限，包括user（属主），group（与属主同一个用户组）， other（其他用户）对文件的rwx权限，7表示全部权限开通 123chmod a+x f01 对文件f01的u,g,o都设置可执行属性,a代表所有用户(u,g,o)sudo chown -R athrun:admin mysql/ 修改文件夹mysql和内部所有文件的所有者为用户athrun，用户组为admin（athrun不属于admin也是可以的） 5. 查看进程信息 lsof(list open files) ps ps -ef | grep nginx 查找和nginx有关系的进程列表 | :管道命令，将上个命令的输出作为下个命令的输入 以查看1099端口占用进程为例： 12lsof -i :1099ps -ef | grep 1099 终止相关进程 1sudo kill -9 PID 6. Java监控(jstat,jmap,jstack) 常规监控： 12jstat -gcutil pid //查看gc情况jstat -gcutil 23613 2000 出现瓶颈时监控： 12345jmap -heap pid // 查看堆内存使用情况jmap -histo pid //打印每个class的实例数目,内存占用,类全名jstack pid &gt; pid.txt //jvm 线程分析top -Hp pid //查看那个线程cpu高，将线程id 转成16进制 在 jstack 导出来的文本文件中查看这个线程在干嘛printf “%x”Tid //打印线程号的16进制 7. 远程文件传输方式一： 12scp scp.test root@172.16.10.4:/tmp/scp.test 从本地上传到远程服务器scp username@servername:/path/filename /tmp/local_destination 从远程下载文件到本地 方式二： 安装lrzsz，使用rz上传文件，sz下载文件TIPs:文件较大时使用rz -e 方式三：FTP 方式四： 使用ssh支持的sftp传输文件到服务器 vsftpd can support FTPS if configured, but sftp runs over ssh. 1.连接远程ftp服务器sftp root@202.206.64.33 2.拉取远程文件到本地sftp&gt; get /var/www/fuyatao/index.php /home/fuyatao/这条语句将从远程主机的 /var/www/fuyatao/目录下将 index.php 下载到本地 /home/fuyatao/目录下。 3.上传本地文件到远程sftp&gt; put /home/fuyatao/downloads/Linuxgl.pdf /var/www/fuyatao/这条语句将把本地 /home/fuyatao/downloads/目录下的 linuxgl.pdf文件上传至远程主机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Phabricator]]></title>
      <url>%2F2016%2F11%2F02%2FProgramming-Summary%2FPhabricator%2F</url>
      <content type="text"><![CDATA[1. 简介 A complete software development platform Phabricator is an integrated set of powerful tools to help companies build higher quality software. 官网) 2. 安装(CentOS)nginx+php-fpm+phabricator git repo+MySql 安装脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#!/bin/bashconfirm() &#123; echo &quot;Press RETURN to continue, or ^C to cancel.&quot;; read -e ignored&#125;RHEL_VER_FILE=&quot;/etc/redhat-release&quot;if [[ ! -f $RHEL_VER_FILE ]]then echo &quot;It looks like you&apos;re not running a Red Hat-derived distribution.&quot; echo &quot;This script is intended to install Phabricator on RHEL-derived&quot; echo &quot;distributions such as RHEL, Fedora, CentOS, and Scientific Linux.&quot; echo &quot;Proceed with caution.&quot; confirmfiecho &quot;PHABRICATOR RED HAT DERIVATIVE INSTALLATION SCRIPT&quot;;echo &quot;This script will install Phabricator and all of its core dependencies.&quot;;echo &quot;Run it from the directory you want to install into.&quot;;echoRHEL_REGEX=&quot;release ([0-9]+)\.&quot;if [[ $(cat $RHEL_VER_FILE) =~ $RHEL_REGEX ]]then RHEL_MAJOR_VER=$&#123;BASH_REMATCH[1]&#125;else echo &quot;Ut oh, we were unable to determine your distribution&apos;s major&quot; echo &quot;version number. Please make sure you&apos;re running 6.0+ before&quot; echo &quot;proceeding.&quot; confirmfiif [[ $RHEL_MAJOR_VER &lt; 6 &amp;&amp; $RHEL_MAJOR_VER &gt; 0 ]]then echo &quot;** WARNING **&quot; echo &quot;A major version less than 6 was detected. Because of this,&quot; echo &quot;several needed dependencies are not available via default repos.&quot; echo &quot;Specifically, RHEL 5 does not have a PEAR package for php53-*.&quot; echo &quot;We will attempt to install it manually, for APC. Please be careful.&quot; confirmfiecho &quot;Phabricator will be installed to: $(pwd).&quot;;confirmecho &quot;Testing sudo/root...&quot;if [[ $EUID -ne 0 ]] # Check if we&apos;re root. If we are, continue.then sudo true SUDO=&quot;sudo&quot; if [[ $? -ne 0 ]] then echo &quot;ERROR: You must be able to sudo to run this script, or run it as root.&quot;; exit 1 fifiif [[ $RHEL_MAJOR_VER == 5 ]]then # RHEL 5&apos;s &quot;php&quot; package is actually 5.1. The &quot;php53&quot; package won&apos;t let us install php-pecl-apc. # (it tries to pull in php 5.1 stuff) ... yum repolist | grep -i epel if [ $? -ne 0 ]; then echo &quot;It doesn&apos;t look like you have the EPEL repo enabled. We are to add it&quot; echo &quot;for you, so that we can install git.&quot; $SUDO rpm -Uvh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm fi YUMCOMMAND=&quot;$SUDO yum install httpd git php53 php53-cli php53-mysql php53-process php53-devel php53-gd gcc wget make pcre-devel mysql-server&quot;else # RHEL 6+ defaults with php 5.3 YUMCOMMAND=&quot;$SUDO yum install httpd git php php-cli php-mysql php-process php-devel php-gd php-pecl-apc php-pecl-json php-mbstring mysql-server&quot;fiecho &quot;Dropping to yum to install dependencies...&quot;echo &quot;Running: $&#123;YUMCOMMAND&#125;&quot;echo &quot;Yum will prompt you with [Y/n] to continue installing.&quot;$YUMCOMMANDif [[ $? -ne 0 ]]then echo &quot;The yum command failed. Please fix the errors and re-run this script.&quot; exit 1fiif [[ $RHEL_MAJOR_VER == 5 ]]then # Now that we&apos;ve ensured all the devel packages required for pecl/apc are there, let&apos;s # set up PEAR, and install apc. echo &quot;Attempting to install PEAR&quot; wget http://pear.php.net/go-pear.phar $SUDO php go-pear.phar &amp;&amp; $SUDO pecl install apcfiif [[ $? -ne 0 ]]then echo &quot;The apc install failed. Continuing without APC, performance may be impacted.&quot;fipidof httpd 2&gt;&amp;1 &gt; /dev/nullif [[ $? -eq 0 ]]then echo &quot;If php was installed above, please run: /etc/init.d/httpd graceful&quot;else echo &quot;Please remember to start the httpd with: /etc/init.d/httpd start&quot;fipidof mysqld 2&gt;&amp;1 &gt; /dev/nullif [[ $? -ne 0 ]]then echo &quot;Please remember to start the mysql server: /etc/init.d/mysqld start&quot;ficonfirmif [[ ! -e libphutil ]]then git clone https://github.com/phacility/libphutil.gitelse (cd libphutil &amp;&amp; git pull --rebase)fiif [[ ! -e arcanist ]]then git clone https://github.com/phacility/arcanist.gitelse (cd arcanist &amp;&amp; git pull --rebase)fiif [[ ! -e phabricator ]]then git clone https://github.com/phacility/phabricator.gitelse (cd phabricator &amp;&amp; git pull --rebase)fiechoechoecho &quot;Install probably worked mostly correctly. Continue with the &apos;Configuration Guide&apos;:&quot;;echoecho &quot; https://secure.phabricator.com/book/phabricator/article/configuration_guide/&quot;; 3 配置(CentOS)3.1 nginx 配置123456789101112131415161718192021222324252627282930313233343536server &#123; listen 85; server_name pha.dev; root /usr/share/phabricator/phabricator/webroot; location / &#123; index index.php; rewrite ^/(.*)$ /index.php?__path__=/$1 last; &#125; location = /favicon.ico &#123; try_files $uri =204; &#125; location /index.php &#123; fastcgi_pass localhost:9000; fastcgi_index index.php; #required if PHP was built with --enable-force-cgi-redirect fastcgi_param REDIRECT_STATUS 200; #variables to make the $_SERVER populate in PHP fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_param GATEWAY_INTERFACE CGI/1.1; fastcgi_param SERVER_SOFTWARE nginx/$nginx_version; fastcgi_param REMOTE_ADDR $remote_addr; &#125;&#125; 3.2 配置MySQL./bin/storage upgrade 3.3 启动nginx/etc/init.d/nginx start 3.4 启动php-fpmetc/init.d/php-fpm start]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提升开发效率的工具]]></title>
      <url>%2F2016%2F10%2F31%2FProgramming-Summary%2F%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[1. Chrome 插件 Postman 新浪微博图床 广告终结者 Scroll to top OneTab 一键存储带打开的网页 2. 在线工具 github star管理工具 gist 管理工具 正则 Linux命令大全 3. Mac 鼠标辅助工具 smoothmouse scrollreverser oh-my-zsh 优化命令行显示效果和操作 Instant Translate 即时翻译 Navicat Premium 数据库工具 Beyond Compare 文件对比工具 SourceTree git可视化工具 Cornerstone svn可视化工具 Alfred 3 MWeb markdown写作工具 iPic 图床工具 SiteSucker 整站下载工具，适合技术博客下载 Sip 拾色器 Kap 录屏工具，输出gif Moom 窗口布局管理工具 NewFileMenu Finder扩展，右键新建文件 4. Android Studio 插件 FindViewByMe 自动根据xml文件生成findView代码 GsonFormat 转换JSON格式到Java类 Markdown Navigator 支持markdown预览 Statistic 代码统计插件 CheckStyle-IDEA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python代码规范]]></title>
      <url>%2F2016%2F10%2F24%2FProgramming-Summary%2FPython%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[一 代码编排1 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。2 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。3 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 二 文档编排1 模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。2 不要在一句import中多个库，比如import os, sys不推荐。3 如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。 三 空格的使用总体原则，避免不必要的空格。1 各种右括号前不要加空格。2 逗号、冒号、分号前不要加空格。3 函数的左括号前不要加空格。如Func(1)。4 序列的左括号前不要加空格。如list[2]。5 操作符左右各加一个空格，不要为了对齐增加空格。6 函数默认参数使用的赋值符左右省略空格。7 不要将多句语句写在同一行，尽管使用‘；’允许。8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 四 注释总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。1 块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如： 12345# Description : Module config.# # Input : None## Output : None 2 行注释，在一句代码后加注释。比如：x = x + 1 # Increment x但是这种方式尽量少使用。3 避免无谓的注释。 五 文档描述1 为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。2 如果docstring要换行，参考如下例子,详见PEP 257 12345&quot;&quot;&quot;Return a foobangOptional plotz says to frobnicate the bizbaz first.&quot;&quot;&quot; 六 命名规范总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。5 异常命名使用CapWords+Error后缀的方式。6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是all机制;二是前缀一个下划线。7 函数命名使用全部小写的方式，可以使用下划线。8 常量命名使用全部大写的方式，可以使用下划线。9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。10 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明a,访问时，只能通过Foo._Fooa，避免歧义。如果子类也叫Foo，那就无能为力了。13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。 七 编码建议1 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。2 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。3 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。4 异常中不要使用裸露的except，except后跟具体的exceptions。5 异常中try的代码尽可能少。6 使用startswith() and endswith()代替切片进行序列前缀或后缀的检查。比如 Yes: if foo.startswith(‘bar’):优于No: if foo[:3] == ‘bar’:7 使用isinstance()比较对象的类型。比如Yes: if isinstance(obj, int): 优于No: if type(obj) is type(1):8 判断序列空或不空，有如下规则Yes: if not seq:if seq:优于No: if len(seq)if not len(seq)9 字符串不要以空格收尾。10 二进制数据判断使用 if boolvalue的方式。 官方推荐PEP8规范]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python环境搭建]]></title>
      <url>%2F2016%2F10%2F23%2FProgramming-Summary%2FPython%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[1. 安装步骤1.1 安装环境MAC OS X EI Capitan(自带python2.7) 1.2 安装python3brew install python3 1.3 安装依赖(使用豆瓣源)pip install pythonModuleName -i https://pypi.douban.com/simple 1.4 依赖包路径 2. 开发环境使用Intellij IDEA Python插件开发。对于我平时写一写脚本，执行一些小操作完全够用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义UI-书架]]></title>
      <url>%2F2016%2F08%2F02%2FProgramming-Summary%2F%E8%87%AA%E5%AE%9A%E4%B9%89UI-%E4%B9%A6%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[1. 效果图 2. 技术细节 事件冲突解决 坐标传递修正 拖动书记卡顿问题解决 拖动避让逻辑设计实现 … 3. 阅读王下载链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于博客的规范]]></title>
      <url>%2F2016%2F07%2F14%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[在你不去改变的时候，事情总是向着坏的方向发展。 为了使博客更方便阅读和理解，制定一份规范很有必要。 1. 组织架构 减少categories数量和深度 2. 排版规范2.1 标题 标题要加序号 标题的字号要匹配 标题的顺序要符合文章主题的逻辑顺序 3. 内容规范3.1 文章长度 简单文章、记录600字符以上 内容含量丰富的1000字符以上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于博客]]></title>
      <url>%2F2016%2F07%2F13%2FProgramming-Summary%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[1. 目的转眼间工作已经一年多，工作中自己成长了很多，但是一直没有做记录，很多有价值的东西没有被记下，感觉甚是遗憾。这个博客就留作记录和查阅之用，解决问题，创造价值。 2. 为什么选择Hexo网上参考了一些博客，发现Hexo使用的比较多，修相关主题丰富，支持MarkDown，自己本来就有用MarkDown记录的习惯，以前也有一些Markdown的文本，整理一下就可以放上来，也是够方便的了。使用GitHub Pages发布服务，服务器和域名的钱也省了。 3. Hexo搭建和使用 3.1 环境和准备工作 nodejs环境 npm module hexo-cli git 熟悉MarkDown语法 3.2 hexo简介 hexo通过配置git地址可以直接使用`hexo d(eploy)’发布到远程git repos。 hexo熟悉修改_config.yml就可以进行常用的一些配置。 默认主题比价鸡肋，经过对比，最后选择了Next，通过官方配置文档，可以开启评论等第三方功能 3.3 常用命令 hexo init blogname初始化博客目录 hexo clean 清除public目录等生成的资源文件 hexo g(enerate)生成public目录等资源文件 hexo server 本地调试服务localhost:4000 参考链接：手把手教你使用Hexo + Github Pages搭建个人独立博客]]></content>
    </entry>

    
  
  
</search>
